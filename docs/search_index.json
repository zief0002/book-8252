[
["index.html", "EPsy 8252 Notes Introduction", " EPsy 8252 Notes Andrew Zieffler 2019-01-29 Introduction This website includes the notes for EPsy 8252: Methods in Data Analysis for Educational Research II. The course website, which includes the syllabus, assignments, etc. can be found at http://zief0002.github.io/epsy-8252/ "],
["rmarkdown.html", "Unit 1: R Markdown 1.1 Notes 1.2 Other Resources", " Unit 1: R Markdown In this set of notes, you will learn how to integrate R syntax directly into your word-processed documents to create more reproducible reports. Preparation Before class you will need to do the following: Download the sample BibTeX file Download the CSL style file for the American Psychological Association 6th edition (single-spaced bibliography) from Zotero’s repository. Install the R package tinytex. See the documentation here. Read the following: Rmarkdown (and friends) Tutorial 1.1 Notes The notes and files you will need can be found at: Unit 01: R Markdown [Class Notes] 1.2 Other Resources In addition to the notes and what we cover in class, there many other resources for learning about R Markdown. Here are some resources that may be helpful in that endeavor: R Markdown documentation: Official R Markdown documentation from RStudio R Markdown cheatsheet: What it sounds like; a cheatsheet for R Markdown knitr: Document and code chunk options for R Markdown R Markdown Gallery: - Gallery of some R Markdown outputs Pimp my Rmd: Blog post providing a few tips to improve the appearance of output documents. For typesetting equations using R Markdown, check out: Using LaTeX to write mathematical content For integrating references into R Markdown, here are a few resources: Zotero CSL style repository Export a BibTeX file from Mendeley Export a BibTeX file from Zotero Here are some references for using reveal.js and remark.js to create sweet-looking presentations: Reveal.js presentations Customizing Reveal.js presentations xaringan Finally here are some other tools for using Markdown in academia: Create a poster with the posterdown package "],
["pretty-printing-tables-in-markdown.html", "Pretty-Printing Tables in Markdown Summary Statistics Table Correlation Table Regression Table: Single Model Regression Table: Multiple Models", " Pretty-Printing Tables in Markdown Often it is useful to format table output to make it look good or to adhere a particular style (e.g., APA). There are several packages that help in this endeavor when working in an Rmarkdown document. Below the primary tools used are: The kable() function from the knitr package; and Functions from the kableExtra package. Other packages for formatting tables, among others, include the gt package, the huxtable package, and the expss package. For complete APA formatting check out the papaja package. The primary input to the kable() function is a data frame. This data frame will include the primary contents for you table. A data frame can either be created as the ouput of a function or directly using the data.frame() function. Below I will create and format a couple different common tables produced for statistical reports. To do so, I will use data from ed-schools-2018.csv file (see the data codebook here). These data include institutional-level attributes for several graduate education schools/programs rated by U.S. News and World Report in 2018. # Load libraries library(AICcmodavg) library(broom) library(corrr) library(dplyr) library(knitr) library(kableExtra) library(readr) library(tidyr) # Read in data ed = read_csv(file = &quot;~/Documents/github/epsy-8252/data/ed-schools-2018.csv&quot;) # Drop rows with missing data educ = ed %&gt;% drop_na() # Create log-transformed variables educ = educ %&gt;% mutate( Lpeer = log(peer), Ldoc_accept = log(doc_accept), Lenroll = log(enroll) ) Summary Statistics Table Say we wanted to produce a table of means and standard deviations for the variables: peer, doc_accept, and enroll. Furthermore, we want these for both the raw (untransformed) and log-transformed versions of these variables. Here is a sketch of what the table should look like: [INSERT SKETCH] To begin we will set up a data frame that includes the information from the table. We do this manually to illustrate use of the data.frame() function to set up a data frame. tab_01 = data.frame( Measure = c(&quot;Peer rating&quot;, &quot;Ph.D. acceptance rate&quot;, &quot;Enrollment&quot;), M_1 = c(mean(educ$peer), mean(educ$doc_accept), mean(educ$enroll)), SD_1 = c(sd(educ$peer), sd(educ$doc_accept), sd(educ$enroll)), M_2 = c(mean(educ$Lpeer), mean(educ$Ldoc_accept), mean(educ$Lenroll)), SD_2 = c(sd(educ$Lpeer), sd(educ$Ldoc_accept), sd(educ$Lenroll)) ) tab_01 Measure M_1 SD_1 M_2 SD_2 1 Peer rating 3.312295 0.4893203 1.187198 0.1439847 2 Ph.D. acceptance rate 40.113115 20.2276300 3.525419 0.6461164 3 Enrollment 969.762295 664.9454219 6.657939 0.7228670 We can now use the kable() function to rename the columns, round the numeric values, and set a caption. kable( tab_01, col.names = c(&quot;Measure&quot;, &quot;*M*&quot;, &quot;*SD*&quot;, &quot;*M*&quot;, &quot;*SD*&quot;), digits = 2, caption = &quot;Means and Standard Deviations of Three Measures of Graduate Programs of Education ($n=122$)&quot; ) Table 1.1: Means and Standard Deviations of Three Measures of Graduate Programs of Education (\\(n=122\\)) Measure M SD M SD Peer rating 3.31 0.49 1.19 0.14 Ph.D. acceptance rate 40.11 20.23 3.53 0.65 Enrollment 969.76 664.95 6.66 0.72 Finally, we use functions from the kableExtra package to add our top header row. kable( tab_01, col.names = c(&quot;Measure&quot;, &quot;*M*&quot;, &quot;*SD*&quot;, &quot;*M*&quot;, &quot;*SD*&quot;), align = c(&quot;l&quot;, &quot;c&quot;, &quot;c&quot;, &quot;c&quot;, &quot;c&quot;), digits = 2, caption = &quot;Means and Standard Deviations of Three Measures of Graduate Programs of Education ($n=122$)&quot; ) %&gt;% add_header_above( header = c(&quot; &quot; = 1, &quot;Untransformed&quot; = 2, &quot;Log-transformed&quot; = 2) ) %&gt;% footnote( general = &quot;Variables were log-transformed using the natural logarithm.&quot;, general_title = &quot;Note.&quot;, footnote_as_chunk = TRUE ) Table 1.2: Means and Standard Deviations of Three Measures of Graduate Programs of Education (\\(n=122\\)) Untransformed Log-transformed Measure M SD M SD Peer rating 3.31 0.49 1.19 0.14 Ph.D. acceptance rate 40.11 20.23 3.53 0.65 Enrollment 969.76 664.95 6.66 0.72 Note. Variables were log-transformed using the natural logarithm. Correlation Table For our second example, say we wanted to produce a table of pairwise correlations for the variables: peer, doc_accept, and enroll. To begin we will again set up a data frame, but this time we will generate it using functions from the corrr package. tab_02 = educ %&gt;% select(peer, doc_accept, enroll) %&gt;% correlate() %&gt;% shave(upper = TRUE) %&gt;% fashion(decimals = 2, na_print = &quot;—&quot;) tab_02 rowname peer doc_accept enroll 1 peer — — — 2 doc_accept -.54 — — 3 enroll .10 -.03 — Now we change the values in the rownames column by mutating in new values, and pipe this into the kable() function, where we will change the column name and add a caption. Keeping the default alignment will align the decimal points within columns. tab_02 %&gt;% mutate( rowname = c(&quot;1. Peer rating&quot;, &quot;2. Ph.D. acceptance rate&quot;, &quot;3. Enrollment&quot;) ) %&gt;% kable( caption = &quot;Correlations between Three Measures of Graduate Programs of Education&quot;, col.names = c(&quot;Measure&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;) ) Table 1.3: Correlations between Three Measures of Graduate Programs of Education Measure 1 2 3 Peer rating — — — Ph.D. acceptance rate -.54 — — Enrollment .10 -.03 — Regression Table: Single Model It is common to report the coefficient-level information from a fitted regression model in a table. The nice thing about using the tidy() function to obtain coefficient-level information from a fitted model is that the output is formatted as a data frame. Thus, we can use the output from tidy() directly in the kable() function. Below I fit a regression model and then use piping to obtain the coefficient-level information and create the table. lm(peer ~ 1 + doc_accept + gre_verbal, data = educ) %&gt;% tidy() %&gt;% kable() term estimate std.error statistic p.value (Intercept) -1.5268 1.6668 -0.916 0.3615 doc_accept -0.0107 0.0019 -5.519 0.0000 gre_verbal 0.0340 0.0106 3.221 0.0016 To format this, we might want to change the column names and round the numerical information to a better number of digits; typically p-values are rounded to three decimal places and coefficients, standard errors and t-values are rounded to two digits. lm(peer ~ 1 + doc_accept + gre_verbal, data = educ) %&gt;% tidy() %&gt;% kable( caption = &quot;Coefficient-Level Estimates for a Model Fitted to Estimate Variation in Peer Ratings.&quot;, col.names = c(&quot;Predictor&quot;, &quot;B&quot;, &quot;SE&quot;, &quot;t&quot;, &quot;p&quot;), digits = c(0, 2, 3, 2, 3) ) Table 1.4: Coefficient-Level Estimates for a Model Fitted to Estimate Variation in Peer Ratings. Predictor B SE t p (Intercept) -1.53 1.667 -0.92 0.362 doc_accept -0.01 0.002 -5.52 0.000 gre_verbal 0.03 0.011 3.22 0.002 Last things to fix are the predictor names and the p-values. The rounding of the p-values has rendered them as zero. We can use the pvalue() function from the scales package to better format the column of p-values. This is carried out prior to piping the output into the kable() function by changing the values in the p.value column. (Note that rather than load a package for a single function we can specify the package directly prior to the function name using two colons; scales::pvalue().) Similarly, we can change the names in the term column at the same time. Lastly, we note that the SEs were truncated when we rounded, so we fix that by increasing the number of digits displayed in that column. lm(peer ~ 1 + doc_accept + gre_verbal, data = educ) %&gt;% tidy() %&gt;% mutate( p.value = scales::pvalue(p.value), term = c(&quot;Intercept&quot;, &quot;Ph.D. acceptance rate&quot;, &quot;Verbal GRE score&quot;) ) %&gt;% kable( caption = &quot;Coefficient-Level Estimates for a Model Fitted to Estimate Variation in Peer Ratings.&quot;, col.names = c(&quot;Predictor&quot;, &quot;B&quot;, &quot;SE&quot;, &quot;t&quot;, &quot;p&quot;), digits = c(0, 2, 3, 2, 3) ) Table 1.5: Coefficient-Level Estimates for a Model Fitted to Estimate Variation in Peer Ratings. Predictor B SE t p Intercept -1.53 1.667 -0.92 0.362 Ph.D. acceptance rate -0.01 0.002 -5.52 &lt;0.001 Verbal GRE score 0.03 0.011 3.22 0.002 One last tweak is that now in the column of p-values, the alignment of the decimal place is off (default alignment for text is left-aligned). We can fix this by changing the alignment to be right-aligned. This is useful for numeric values so that the decimal points within a column line up. lm(peer ~ 1 + doc_accept + gre_verbal, data = educ) %&gt;% tidy() %&gt;% mutate( p.value = scales::pvalue(p.value), term = c(&quot;Intercept&quot;, &quot;Ph.D. acceptance rate&quot;, &quot;Verbal GRE score&quot;) ) %&gt;% kable( caption = &quot;Coefficient-Level Estimates for a Model Fitted to Estimate Variation in Peer Ratings.&quot;, col.names = c(&quot;Predictor&quot;, &quot;B&quot;, &quot;SE&quot;, &quot;t&quot;, &quot;p&quot;), digits = c(0, 2, 3, 2, 3), align = c(&quot;l&quot;, &quot;r&quot;, &quot;r&quot;, &quot;r&quot;, &quot;r&quot;) ) Table 1.6: Coefficient-Level Estimates for a Model Fitted to Estimate Variation in Peer Ratings. Predictor B SE t p Intercept -1.53 1.667 -0.92 0.362 Ph.D. acceptance rate -0.01 0.002 -5.52 &lt;0.001 Verbal GRE score 0.03 0.011 3.22 0.002 Regression Table: Multiple Models There are several specific packages that help us create tables of regression results. The Stargazer package, the texreg package and the finalfit package are but a few of these. I tend to use both the texreg package (more customizable) and the stargazer package (easier). Below I illustrate how to create a table of regression results using the stargazer package. First we fit a few models. # Fit candidate models lm.1 = lm(peer ~ 1 + doc_accept, data = educ) lm.2 = lm(peer ~ 1 + enroll, data = educ) lm.3 = lm(peer ~ 1 + doc_accept + enroll, data = educ) After loading the stagazer package, the stargazer() function can be used to create a basic table of regression results. The type= argument defaults to latex, so if you are rendering to an HTML document, you need to change this to type=\"html\". library(stargazer) stargazer(lm.1, lm.2, lm.3, type = &quot;html&quot;) &lt;table style=&quot;text-align:center&quot;&gt;&lt;tr&gt;&lt;td colspan=&quot;4&quot; style=&quot;border-bottom: 1px solid black&quot;&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;&lt;td colspan=&quot;3&quot;&gt;&lt;em&gt;Dependent variable:&lt;/em&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td colspan=&quot;3&quot; style=&quot;border-bottom: 1px solid black&quot;&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;&lt;td colspan=&quot;3&quot;&gt;peer&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;&lt;td&gt;(1)&lt;/td&gt;&lt;td&gt;(2)&lt;/td&gt;&lt;td&gt;(3)&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td colspan=&quot;4&quot; style=&quot;border-bottom: 1px solid black&quot;&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;text-align:left&quot;&gt;doc_accept&lt;/td&gt;&lt;td&gt;-0.013&lt;sup&gt;***&lt;/sup&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;-0.013&lt;sup&gt;***&lt;/sup&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;&lt;td&gt;(0.002)&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;(0.002)&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td style=&quot;text-align:left&quot;&gt;enroll&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;0.0001&lt;/td&gt;&lt;td&gt;0.0001&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;(0.0001)&lt;/td&gt;&lt;td&gt;(0.0001)&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td style=&quot;text-align:left&quot;&gt;Constant&lt;/td&gt;&lt;td&gt;3.836&lt;sup&gt;***&lt;/sup&gt;&lt;/td&gt;&lt;td&gt;3.238&lt;sup&gt;***&lt;/sup&gt;&lt;/td&gt;&lt;td&gt;3.769&lt;sup&gt;***&lt;/sup&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;&lt;td&gt;(0.083)&lt;/td&gt;&lt;td&gt;(0.078)&lt;/td&gt;&lt;td&gt;(0.101)&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td colspan=&quot;4&quot; style=&quot;border-bottom: 1px solid black&quot;&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;text-align:left&quot;&gt;Observations&lt;/td&gt;&lt;td&gt;122&lt;/td&gt;&lt;td&gt;122&lt;/td&gt;&lt;td&gt;122&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td style=&quot;text-align:left&quot;&gt;R&lt;sup&gt;2&lt;/sup&gt;&lt;/td&gt;&lt;td&gt;0.292&lt;/td&gt;&lt;td&gt;0.011&lt;/td&gt;&lt;td&gt;0.300&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td style=&quot;text-align:left&quot;&gt;Adjusted R&lt;sup&gt;2&lt;/sup&gt;&lt;/td&gt;&lt;td&gt;0.286&lt;/td&gt;&lt;td&gt;0.003&lt;/td&gt;&lt;td&gt;0.288&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td style=&quot;text-align:left&quot;&gt;Residual Std. Error&lt;/td&gt;&lt;td&gt;0.414 (df = 120)&lt;/td&gt;&lt;td&gt;0.489 (df = 120)&lt;/td&gt;&lt;td&gt;0.413 (df = 119)&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td style=&quot;text-align:left&quot;&gt;F Statistic&lt;/td&gt;&lt;td&gt;49.400&lt;sup&gt;***&lt;/sup&gt; (df = 1; 120)&lt;/td&gt;&lt;td&gt;1.328 (df = 1; 120)&lt;/td&gt;&lt;td&gt;25.490&lt;sup&gt;***&lt;/sup&gt; (df = 2; 119)&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td colspan=&quot;4&quot; style=&quot;border-bottom: 1px solid black&quot;&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td style=&quot;text-align:left&quot;&gt;&lt;em&gt;Note:&lt;/em&gt;&lt;/td&gt;&lt;td colspan=&quot;3&quot; style=&quot;text-align:right&quot;&gt;&lt;sup&gt;*&lt;/sup&gt;p&lt;0.1; &lt;sup&gt;**&lt;/sup&gt;p&lt;0.05; &lt;sup&gt;***&lt;/sup&gt;p&lt;0.01&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; The function outputs raw HTML (or LaTeX), so to get it to form into a table you need to include results='asis' in your Rmarkdown chunk. ```{r message=FALSE, results=&#39;asis&#39;} library(stargazer) stargazer(lm.1, lm.2, lm.3, type = &quot;html&quot;) ``` Dependent variable: peer (1) (2) (3) doc_accept -0.013*** -0.013*** (0.002) (0.002) enroll 0.0001 0.0001 (0.0001) (0.0001) Constant 3.836*** 3.238*** 3.769*** (0.083) (0.078) (0.101) Observations 122 122 122 R2 0.292 0.011 0.300 Adjusted R2 0.286 0.003 0.288 Residual Std. Error 0.414 (df = 120) 0.489 (df = 120) 0.413 (df = 119) F Statistic 49.400*** (df = 1; 120) 1.328 (df = 1; 120) 25.490*** (df = 2; 119) Note: p&lt;0.1; p&lt;0.05; p&lt;0.01 There are several arguments in the stargazer() function to customize the table. stargazer( lm.1, lm.2, lm.3, type = &quot;html&quot;, title = &quot;Three Regression Models Predicting Variation in Peer Ratings&quot;, column.labels = c(&quot;Model A&quot;, &quot;Model B&quot;, &quot;Model C&quot;), colnames = FALSE, model.numbers = FALSE, dep.var.caption = &quot; &quot;, dep.var.labels = &quot;Peer rating (1-5 scale)&quot;, covariate.labels = c(&quot;Ph.D. acceptance rate&quot;, &quot;Enrollment&quot;), keep.stat = c(&quot;rsq&quot;, &quot;f&quot;), notes.align = &quot;l&quot;, add.lines = list(c(&quot;Corrected AIC&quot;, round(AICc(lm.1), 1), round(AICc(lm.2), 1), round(AICc(lm.3), 1))), out = &quot;images/table1.html&quot; ) Three Regression Models Predicting Variation in Peer Ratings Peer rating (1-5 scale) Model AModel BModel C Ph.D. acceptance rate-0.013***-0.013*** (0.002)(0.002) Enrollment0.00010.0001 (0.0001)(0.0001) Constant3.836***3.238***3.769*** (0.083)(0.078)(0.101) Corrected AIC135175.7135.7 R20.2920.0110.300 F Statistic49.400*** (df = 1; 120)1.328 (df = 1; 120)25.490*** (df = 2; 119) Note:*p**p***p There is a known bug with the stargazer table not printing the asterisks next to the significance values in the notes section of the table when outputting to HTML. The solution as documented here is to output the html code to an external file using the out= argument in stargazer() and then inserting that html code in a new code chunk via the includeHTML() function from the htmltools package. The add.lines= argument adds a line to the bottom of the output. This argument takes a list that includes the name you want to output in the regression table and then the value to output for each of the models. Here we computed the corrected AIC value using the AICc() function from the AICmodavg package for each of the models. (Note: We will learn about this in the More Information Criteria for Model Selection unit.) "],
["nonlinearity-log-transforming-the-predictor.html", "Unit 2: Nonlinearity: Log-Transforming the Predictor 2.1 Dataset and Research Question 2.2 Log-Transformation of a Variable 2.3 Fitting the Regression Model 2.4 Alternative Method of Fitting the Model 2.5 Plotting the Fitted Model 2.6 Different Base Values in the Logarithm 2.7 Base-\\(e\\) Logarithm: The Natural Logarithm 2.8 Including Covariates 2.9 Polynomial Effects vs. Log-Transformations Other Resources", " Unit 2: Nonlinearity: Log-Transforming the Predictor In this set of notes, you will learn about log-transforming the predictor in a regression model to account for nonlinearity. Preparation Before class you will need to do the following: Refresh your knowledge about logarithms by going though the Khan Academy Intro to Logarithms tutorial. 2.1 Dataset and Research Question The data we will use in this set of notes, mn-schools.csv (see the data codebook here), contains 2011 institutional data for \\(n=33\\) Minnesota colleges and universities. # Load libraries library(broom) library(dplyr) library(ggplot2) library(readr) library(sm) library(tidyr) # Import data mn = read_csv(file = &quot;~/Documents/github/epsy-8252/data/mn-schools.csv&quot;) head(mn) # A tibble: 6 x 6 id name grad public sat tuition &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 1 Augsburg College 65.2 0 10.3 39.3 2 3 Bethany Lutheran College 52.6 0 10.6 30.5 3 4 Bethel University, Saint Paul, MN 73.3 0 11.4 39.4 4 5 Carleton College 92.6 0 14 54.3 5 6 College of Saint Benedict 81.1 0 11.8 43.2 6 7 Concordia College at Moorhead 69.4 0 11.4 36.6 Using these data, we will examine if (and how) academic “quality” of the student-body (measured by median composite SAT score) is related to institutional graduation rates. 2.2 Log-Transformation of a Variable Recall that the scatterplot of SAT scores and graduation rates suggested that the relationship between these variables was curvilinear. Figure 2.1: Scatterplot of the relationship between median SAT score and six-year graduation rate. The loess smoother is also displayed. One way to model this nonlinearity was to fit a model that included a polynomial effect (quadratic). Another method of modeling nonlinearity is to transform the predictor (or outcome) using a nonlinear transformation. One commonly used nonlinear transformation is the logarithm. Below is a comparison of the quadratic function to the logarithmic function. Figure 2.2: Quadratic and logarithmic functions. The quadratic function shows continuous and diminishing growth followed by continuous and increasing loss (parabola; the function changes direction), while the logarithmic function models continuous, albeit diminishing, growth (the function does not change direction). 2.2.1 Quick Refresher on Logarithms The logarithm is an inverse function of an exponent. Consider this example, \\[ \\log_2 (32) \\] The logarithm of 32 is the exponent to which the base, 2 in our example, must be raised to produce that number. In other words, \\[ \\log_2 (32) \\longrightarrow 2^{x} = 32 \\longrightarrow x=5 \\] Thus, \\[ \\log_2 (32) = 5 \\] To compute a logarithm using R, we use the log() function. We also specify the argument base=, since logarithms are unique to a particular base. For example, to compute the mathematical expression \\(\\log_2 (32)\\), we use log(32, base = 2) [1] 5 There is also a shortcut function to use base-2. log2(32) [1] 5 2.2.2 Log-Transforming Variables For our purposes, we need to log-transform each value in a particular variable. Here, we will log-transform the SAT variable (using base-2). mn = mn %&gt;% mutate( L2sat = log(sat, base = 2) ) head(mn) # A tibble: 6 x 7 id name grad public sat tuition L2sat &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 1 Augsburg College 65.2 0 10.3 39.3 3.36 2 3 Bethany Lutheran College 52.6 0 10.6 30.5 3.41 3 4 Bethel University, Saint Paul, MN 73.3 0 11.4 39.4 3.52 4 5 Carleton College 92.6 0 14 54.3 3.81 5 6 College of Saint Benedict 81.1 0 11.8 43.2 3.57 6 7 Concordia College at Moorhead 69.4 0 11.4 36.6 3.52 How does this log-transformed variable compare to the original SAT predictor. We can examine the density plot of both the original and log-transformed variables to answer this. Comparing the shapes of the two variables, we see that the original variable was right-skewed. The log-transformed variable is also right-skewed, although it is LESS right-skewed than the original. The scale is quite different between the two variables (one is, after all, log-transformed). This has greatly affected the variation. After log-transforming, the variation is much smaller. What happens when we use the log-transformed variable in a scatterplot with graduation rates? ggplot(data = mn, aes(x = L2sat, y = grad)) + geom_point() + geom_smooth(se = FALSE) + theme_bw() + xlab(&quot;Log-transformed SAT score&quot;) + ylab(&quot;Six-year graduation rate&quot;) Figure 2.3: Scatterplot of the relationship between log-transformed median SAT score (base-2) and six-year graduation rate. The loess smoother is also displayed. The relationship between graduation rate and the log-transformed SAT scores is MORE linear than the relationship between graduation rates and the untransformed SAT scores. By transforming the variable using a nonlinear transformation (log) we have “linearized” the relationship with graduation rates. As such, we can fit a linear model to predict graduation rates using the Log-transformed SAT scores as a predictor. 2.3 Fitting the Regression Model To fit the model, we use the lm() function and input the log-transformed SAT scores as the predictor. lm.1 = lm(grad ~ 1 + L2sat, data = mn) 2.3.1 Examine the Assumption of Linearity Before examining the coefficients, we can scrutinize the residuals to see whether the log-transformation helped us meet the assumption of linearity. # Obtain residuals out = augment(lm.1) # Check linearity assumptions ggplot(data = out, aes(x = .fitted, y = .std.resid)) + geom_point() + geom_hline(yintercept = 0) + geom_smooth() + theme_bw() The assumption looks reasonably met as the horizontal line of \\(y=0\\) is encompassed in the confidence envelope of the loess smoother. 2.3.2 Interpret the Regression Results We can now look at the regression output and interpret the results. # Model-level output glance(lm.1) Examining the model-level output, we see that differences in \\(\\log_2(\\mathrm{SAT})\\) explain 81.13% of the variation in graduation rates. This is statistically significant, \\(F(1,~31)=133.3\\), \\(p&lt;.001\\). Since differences in \\(\\log_2(\\mathrm{SAT})\\) imply that there are differences in the raw SAT scores, we would typically just say that “differences in SAT scores explain 81.13% of the variation in graduation rates.” Moving to the coefficient-level output, # Coefficient-level output tidy(lm.1) We can write the fitted equation as, \\[ \\hat{\\mathrm{Graduation~Rate}} = -306.7 + 106.4\\bigg[\\log_2(\\mathrm{SAT})\\bigg] \\] We can interpret the coefficients as we always do, recognizing that these interpretation are based on the log-transformed predictor. The intercept value of \\(-306.7\\) is the predicted average graduation rate for all colleges/universities with a \\(\\log_2(\\mathrm{SAT})\\) value of 0. The slope value of 106.4 indicates that each one-unit difference in \\(\\log_2(\\mathrm{SAT})\\) is associated with a 106.4-unit difference in graduation rate, on average. 2.3.3 Better Interpretations: Back-transforming While these interpretations are technically correct, it is more helpful to your readers (and more conventional) to interpret any regression results in the metric of SAT scores rather than log-transformed SAT scores. This means we have to back-transform the interpretations. To back-transform a logarithm, we use its inverse function; exponentiation. We interpreted the intercept as, “the predicted average graduation rate for all colleges/universities with a \\(\\log_2(\\mathrm{SAT})\\) value of 0”. To interpret this using the metric of our SAT attribute, we have to understand what \\(\\log_2(\\mathrm{SAT}) = 0\\) is. \\[ \\log_2 (\\mathrm{SAT}) = 0 \\longrightarrow 2^{0} = \\mathrm{SAT} \\] In this computation, \\(\\mathrm{SAT}=1\\). Thus, rather than using the log-transformed interpretation, we can, instead, interpret the intercept as, The predicted average graduation rate for all colleges/universities with a SAT measurement of 1 (median SAT = 100) is \\(-306.7\\). Since there are no colleges/universities in our data that have a SAT value of 1, this is extrapolation. What about the slope? Our interpretation was that “each one-unit difference in \\(\\log_2(\\mathrm{SAT})\\) is associated with a 106.4-unit difference in graduation rate, on average.” Working with the same ideas of back-transformation, we need to understand what a one-unit difference in \\(\\log_2(\\mathrm{SAT})\\) means. Consider four values of \\(\\log_2(\\mathrm{SAT})\\) that are each one-unit apart: \\[ \\log_2(\\mathrm{SAT}) = 1\\\\ \\log_2(\\mathrm{SAT}) = 2\\\\ \\log_2(\\mathrm{SAT}) = 3\\\\ \\log_2(\\mathrm{SAT}) = 4 \\] If we back-transform each of these, then we can see how the four values of the raw SAT variable would differ. \\[ \\begin{split} \\mathrm{SAT} &amp;= 2^1 = 2\\\\ \\mathrm{SAT} &amp;= 2^2 = 4\\\\ \\mathrm{SAT} &amp;= 2^3 = 8\\\\ \\mathrm{SAT} &amp;= 2^4 = 16 \\end{split} \\] When \\(\\log_2(\\mathrm{SAT})\\) is increased by one-unit, the raw SAT value is doubled. We can use this in our interpretation of slope: A doubling of the SAT value is associated with a 106.4-unit difference in graduation rate, on average. The technical language for doubling is a “two-fold difference”. So we would conventionally interpret this as: Each two-fold difference in SAT value is associated with a 106.4-unit difference in graduation rate, on average. To understand this further, consider a specific school, say Augsburg. Their measurement on the SAT variable is 10.3, and their log-transformed SAT score is 3.36. Using the fitted regression equation (which employs the log-transformed SAT), -306.7 + 106.4 * 3.36 [1] 50.8 Augsburg’s predicted graduation rate would be 50.8. If we increase the L2sat score by 1 to 4.36 (which is equivalent to a raw SAT measurement of 20.6; double 10.3), their predicted graduation rate is, -306.7 + 106.4 * 4.36 [1] 157.2 This is an increase of 106.4. 2.4 Alternative Method of Fitting the Model Rather that create the log-transformed SAT score in the data, we can use the log() function on SAT directly in the lm() computation. lm.1 = lm(grad ~ 1 + log(sat, base = 2), data = mn) # Model-level output glance(lm.1) # Coefficient-level output tidy(lm.1) Using this method of fitting the model will be useful as we plot the fitted model. 2.5 Plotting the Fitted Model To aid interpretation of the effect of SAT on graduation rate, we can plot the fitted model. If we used the method of fitting in which we used log() directly in the lm() function, we only need to set up a sequence of SAT values, predict graduation rates using the fitted model, and finally connect these values using a line. # Set up data plot_data = crossing( sat = seq(from = 8.9, to = 14.0, by = 0.1) ) %&gt;% mutate( # Predict yhat = predict(lm.1, newdata = .) ) # Examine data head(plot_data) # Plot ggplot(data = plot_data, aes(x = sat, y = yhat)) + geom_line() + theme_bw() + xlab(&quot;Median SAT score (in hundreds)&quot;) + ylab(&quot;Predicted graduation rate&quot;) Figure 2.4: Plot of the predicted graduation rates as a function of median SAT score (in hundreds). The non-linearity in the plot indicates that there is a diminishing positive effect of SAT on graduation rates. 2.6 Different Base Values in the Logarithm The base value we used in the log() function in the previous example was base-2. Using a base value of 2 was an arbitrary choice. We can use any base value we want. For example, what happens if we use base-10. mn = mn %&gt;% mutate( L10sat = log(mn$sat, base = 10) ) # Examine data head(mn) # A tibble: 6 x 8 id name grad public sat tuition L2sat L10sat &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 1 Augsburg College 65.2 0 10.3 39.3 3.36 1.01 2 3 Bethany Lutheran College 52.6 0 10.6 30.5 3.41 1.03 3 4 Bethel University, Saint P… 73.3 0 11.4 39.4 3.52 1.06 4 5 Carleton College 92.6 0 14 54.3 3.81 1.15 5 6 College of Saint Benedict 81.1 0 11.8 43.2 3.57 1.07 6 7 Concordia College at Moorh… 69.4 0 11.4 36.6 3.52 1.06 Comparing the logarithms of the SAT attribute using base-10 to those using base-2 we see that the base-10 logarithms are smaller. This is because now we are using the base of 10 in our exponent (rather than 2). For example, for Augsburg, \\[ 10^{1.013} = 10.3 \\] If we fit a model using the base-10 logarithm, lm.2 = lm(grad ~ 1 + log(sat, base = 10), data = mn) # Model-level output glance(lm.2) Examining the model-level output, we see that differences in \\(\\log_{10}(\\mathrm{SAT})\\) explain 81.13% of the variation in graduation rates. Or simply, that differences in SAT scores explain 81.13% of the variation in graduation rates. This is statistically significant, \\(F(1,~31)=133.3\\), \\(p&lt;.001\\). These model-level results are the same as when we used the base-2 logarithm. # Coefficient-level output tidy(lm.2) The fitted equation is, \\[ \\hat{\\mathrm{Graduation~Rate}} = -306.7 + 353.6\\bigg[\\log_{10}(\\mathrm{SAT})\\bigg] \\] We can interpret the coefficients using the base-10 logarithm of SAT scores as: The intercept value of \\(-306.7\\) is the predicted average graduation rate for all colleges/universities with a \\(\\log_{10}(\\mathrm{SAT})\\) value of 0. The slope value of 353.6 indicates that each one-unit difference in \\(\\log_{10}(\\mathrm{SAT})\\) is associated with a 353.6-unit difference in graduation rate, on average. Better yet, we can back-transform the interpretations so that we are using SAT scores rather than \\(\\log_{10}(\\mathrm{SAT})\\) scores. The predicted average graduation rate for all colleges/universities with a SAT value of 1 (median SAT score = 100) is \\(-306.7\\). Each ten-fold difference in SAT is associated with a 353.6-unit difference in graduation rate, on average. To further think about the effect of SAT, if Augsburg improved its median SAT score ten-fold (i.e., going from a SAT value of 10.3 to a value of 103) we would predict its graduation rate to go up by 353.6. 2.6.1 Comparing the Output from the Two Bases The model-level information is all the same. Furthermore, the intercepts (and SE and \\(p\\)-value) was the same across both models. The slope coefficients and SEs were different in the two models, but the \\(t\\)-value and \\(p\\)-value for the effect of SAT was identical for both base-2 and base-10. The only real difference in using base-10 vs. base-2 in the logarithm is in the interpretation of the SAT effect. What if we look at the residual fit? Figure 2.5: Standardized residuals versus the fitted values for the models fitted with the log-2 predictor (left) and the log-10 predictor (right). The residuals fit EXACTLY the same. Why is this? Let’s again use Augsburg as an example. Using the fitted model that employed the base-2 logarithm, we found that Augsburg’s predicted graduation rate was, \\[ \\begin{split} \\hat{\\mathrm{Graduation~Rate}} &amp;= -306.7 + 106.4\\bigg[\\log_2(10.3)\\bigg] \\\\ &amp;= -306.7 + 106.4\\bigg[3.36\\bigg] \\\\ &amp;= 50.8 \\end{split} \\] Using the model that employed the base-10 logarithm, Augsburg’s predicted graduation rate would be \\[ \\begin{split} \\hat{\\mathrm{Graduation~Rate}} &amp;= -306.7 + 353.6\\bigg[\\log_{10}(10.3)\\bigg] \\\\ &amp;= -306.7 + 353.6\\bigg[1.01\\bigg] \\\\ &amp;= 50.8 \\end{split} \\] Augsburg’s predicted graduation rate is exactly the same in the two models. This implies that Augsburg’s residual would also be the same in the two models. This is true for every college. Because of this, increasing (or decreasing) the base used in the logarithm does not help improve the fit of the model. The fit is exactly the same no matter which base you choose. The only thing that changes when you choose a different base is the interpretation of the slope. You should choose the base to facilitate interpretation. For example, does it make more sense to talk about a two-fold difference in the predictor? A five-fold difference in the predictor? A ten-fold difference in the predictor? 2.7 Base-\\(e\\) Logarithm: The Natural Logarithm In our example, neither of the bases we examined is satisfactory in terms of talking about the effect of SAT. Two-fold differences in SAT are very unlikely, to say anything of ten-fold differences. One base that is commonly used for log-transformations is base-\\(e\\). \\(e\\) is a mathematical constant (Euler’s number) that is approximately equal to 2.71828. We can obtain this by using the exp() function in R. This function takes \\(e\\) to some exponent that is given as the argument. So to obtain the approximation of \\(e\\) we use exp(1) [1] 2.718 The logarithm (base-\\(e\\)) for a number, referred to as the natural logarithm, can be obtained using the log() function with the argument base=exp(1). However, this base is so commonly used that it is the default value for the base= argument. So, if we use the log() function without defining the base= argument, it will automatically use base-\\(e\\). For example, the natural logarithm of Augsburg’s SAT score of 1030 can be computed as log(10.3) [1] 2.332 If we took \\(e^{2.332}\\) we would obtain 10.3. The natural logarithm even has its own mathematical notation; \\(\\ln\\). For example, we would mathematically express the natural logarithm of 10.3 as \\[ \\ln (10.3) = 2.332. \\] 2.7.1 Using the Natural Logarithm in a Regression Model Below we regress graduation rates on the log-transformed SAT scores, using the natural logarithm. # Fit model lm.3 = lm(grad ~ 1 + log(sat), data = mn) # Model-level output glance(lm.3) As with any base, using base-\\(e\\) results in the same model-level information (\\(R^2=.811\\), \\(F(1,~31)=133.3\\), \\(p&lt;.001\\)). # Coefficient-level output tidy(lm.3) The intercept has the same coefficient (\\(\\hat\\beta_0=-306.7\\)), SE, \\(t\\)-value, and \\(p\\)-value as the intercept from the models using base-2 and base-10 log-transformations of SAT. (This is, again, because \\(2^0=10^0=e^0=1\\).) And, although the coefficient and SE for the effect of SAT is again different (a one-unit change in the three different log-scales does not correspond to the same amount of change in raw SAT for the three models), the \\(t\\)-value and level of statistical significance (\\(t(31)=11.55\\), \\(p&lt;.001\\)) for this effect, are the same as when we used base-2 and base-10. So how can we interpret the model’s coefficients? The intercept can be interpreted exactly the same as in the previous models in which we used base-2 or base-10; namely that the predicted average graduation rate for colleges/universities with a SAT value of one is \\(-306.7\\). Interpreting the slope, we could say that an \\(e\\)-fold difference in SAT value is associated with a 153.6-unit difference in graduation rates, on average. 2.7.1.1 Interpretation Using Percentage Change Consider three schools, each having a SAT score that differs by 1%; say these schools have SAT values of 10, 10.1, 10.2. Using the fitted equation, we can compute the predicted graduation rate for each of these hypothetical schools: \\[ \\hat{\\mathrm{Graduation~Rate}} = -306.7 + 153.6 \\bigg[\\ln (\\mathrm{SAT})\\bigg] \\] The SAT values and predicted graduation rates for these schools are given below: Table 2.1: SAT values and Graduation Rates for Three Hypothetical Schools that have SAT Values that Differ by One Percent. SAT Predicted Graduation Rate 10.0 46.88 10.1 48.41 10.2 49.93 The difference between each subsequent predicted graduation rate is 1.53. 48.4058 - 46.8778 [1] 1.528 49.9338 - 48.4058 [1] 1.528 In other words, schools that have a SAT value that differ by 1%, have predicted graduation rates that differ by 1.53, on average. 2.7.1.2 Mathematical Explanation To understand how we can directly compute this difference, consider the predicted values for two \\(x\\)-values that differ by one-percent, if we use symbolic notation: \\[ \\begin{split} \\hat{y}_1 &amp;= \\hat\\beta_0 + \\hat\\beta_1\\left[\\ln(x)\\right] \\\\ \\hat{y}_2 &amp;= \\hat\\beta_0 + \\hat\\beta_1\\left[\\ln(1.01x)\\right] \\end{split} \\] The difference in their predicted values is: \\[ \\begin{split} \\hat{y}_2 - \\hat{y}_1 &amp;= \\hat\\beta_0 + \\hat\\beta_1\\left[\\ln(1.01x)\\right] - \\left(\\hat\\beta_0 + \\hat\\beta_1\\left[\\ln(x)\\right]\\right) \\\\ &amp;=\\hat\\beta_0 + \\hat\\beta_1\\left[\\ln(1.01x)\\right] - \\hat\\beta_0 - \\hat\\beta_1\\left[\\ln(x)\\right] \\\\ &amp;=\\hat\\beta_1\\left[\\ln(1.01x)\\right] - \\hat\\beta_1\\left[\\ln(x)\\right] \\\\ &amp;=\\hat\\beta_1\\left[\\ln(1.01x) - \\ln(x)\\right]\\\\ &amp;=\\hat\\beta_1\\left[\\ln(\\frac{1.01x}{1x})\\right] \\end{split} \\] If we substitute in any value for \\(x\\), we can now directly compute this constant difference. Note that a convenient value for \\(x\\) is 1. Then this reduces to: \\[ \\hat\\beta_1\\left[\\ln(1.01)\\right] \\] So now, we can interpret this as: a one-percent difference in \\(x\\) is associated with a \\(\\hat\\beta_1\\left[\\ln(1.01)\\right]\\)-unit difference in \\(Y\\), on average. In our model, we can compute this difference using the fitted coefficient \\(\\hat\\beta_1=153.6\\) as \\[ 153.6\\left[\\ln(1.01)\\right] = 1.528371 \\] The same computation using R is 153.6 * log(1.01) [1] 1.528 This gives you the constant difference exactly. So you can interpret the effect of SAT as, each 1% difference in SAT score is associated with a difference in graduation rates of 1.53, on average. 2.7.1.3 Approximate Interpretation We can get an approximate estimate for the size of the effect by using the mathematical shortcut of \\[ \\mathrm{Effect} \\approx \\frac{\\hat\\beta_1}{100} \\] Using our fitted results, we could approximate the size of the effect as, \\[ \\frac{153.6}{100} = 1.536 \\] We could then interpret the effect of SAT by saying a 1% difference in median SAT score is associated with a 1.53-unit difference in predicted graduation rate, on average. 2.8 Including Covariates We can also include covariates in the model. Below we examine the nonlinear effect of SAT on graduation controlling for differences in sector. # Fit model lm.4 = lm(grad ~ 1 + public + log(sat), data = mn) # Model-level output glance(lm.4) The model explains 86.5% of the variation in graduation rates, \\(F(2,~30)=96.58\\), \\(p&lt;.001\\). # Coefficient-level output tidy(lm.4) Interpreting each of the coefficients using the raw SAT scores: The intercept value of \\(-286.1\\) is the predicted average graduation rate for all public colleges/universities with a SAT value of 1 (extrapolation). There is a statistically significant effect of sector after controlling for differences in SAT score (\\(p=.002\\)). Public schools have a predicted graduation rate that is 8.5-units lower, on average, than private schools controlling for differences in median SAT scores. There is a statistically significant effect of SAT on graduation rates, controlling for differences in sector (\\(p&lt;.001\\)). A 1% difference in median SAT value is associated with a 1.46-unit difference in predicted graduation rate, on average, after controlling for differences in sector. 2.8.1 Plot of the Model Results To further help interpret these effects, we can plot the fitted model. # Set up data plot_data = crossing( sat = seq(from = 8.9, to = 14.0, by = .1), public = c(0, 1) ) %&gt;% mutate( yhat = predict(lm.4, newdata = .), public = factor(public, levels = c(0, 1), labels = c(&quot;Private&quot;, &quot;Public&quot;)) ) #Examine data head(plot_data) # Plot ggplot(data = plot_data, aes(x = sat, y = yhat, color = public, linetype = public)) + geom_line() + theme_bw() + xlab(&quot;Median SAT score (in hundreds)&quot;) + ylab(&quot;Predicted graduation rate&quot;) + ggsci::scale_color_d3(name = &quot;Sector&quot;) + scale_linetype_manual(name = &quot;Sector&quot;, values = c(&quot;solid&quot;, &quot;dashed&quot;)) Figure 2.6: Predicted graduation rate as a function of median SAT score (in hundreds) and sector. The effect of SAT is log-linear. The plot shows the nonlinear, diminishing positive effect of SAT on graduation rate for both public and private schools. For schools with lower median SAT scores, there is a larger effect on graduation rates than for schools with higher median SAT scores (for both private and public schools). The plot also shows the controlled effect of sector. For schools with the same median SAT score, private schools have a higher predicted graduation rate than public schools, on average. 2.9 Polynomial Effects vs. Log-Transformations The inclusion of polynomial effects and the use of a log-transformation was to model the nonlinearity observed in the relationship between SAT scores and graduation rates. Both methods were successful in this endeavor. While either method could be used in practice to model nonlinearity, there are some considerations when making the choice of which may be more appropriate for a given modeling situation. The first consideration is one of theory. The plot below shows the mathematical function for a log-transformed \\(X\\)-value (solid, black line) and for a quadratic polynomial of \\(X\\) (dashed, red line). Figure 2.7: Comparison of quadratic (blue, dashed) and logarithmic (black, solid) functions of X. Both functions are nonlinear, however the polynomial function changes direction. For low values of \\(X\\), the function has a large positive effect. This effect diminishes as \\(X\\) gets bigger, and around \\(X=9\\) the effect is zero. For larger values of \\(X\\), the effect is actually negative. For the logarithmic function, the effect is always positive, but it diminishes as \\(X\\) gets larger. (Functions that constantly increase, or constantly decrease, are referred to as monotonic functions.) Theoretically, these are very different ideas, and if substantive literature suggests one or the other, you should probably acknowledge that in the underlying statistical model that is fitted. Empirically, the two functions are very similar especially within certain ranges of \\(X\\). For example, although the predictions from these models would be quite different for really high values of \\(X\\), if we only had data from the range of 2 to 8 (\\(2\\leq X \\leq 8\\)) both functions would produce similar residuals. In this case, the residuals would likely not suggest better fit for either of the two models. In this case, it might be prudent to think about Occam’s Razor—if two competing models produce similar predictions, adopt the simpler model. Between these two functions, the log-transformed model is simpler; it has one predictor compared to the two predictors in the quadratic model. The mathematical models make this clear: \\[ \\begin{split} \\mathbf{Polynomial:~}Y_i &amp;= \\beta_0 + \\beta_1(X_i) + \\beta_2(X_i^2) +\\epsilon_i \\\\ \\mathbf{Log\\mbox{-}Transform:~}Y_i &amp;= \\beta_0 + \\beta_1\\bigg[\\ln(X_i)\\bigg] + \\epsilon_i \\end{split} \\] The quadratic polynomial model has two effects: a linear effect of \\(X\\) and a quadratic effect of \\(X\\) (remember it is an interaction model), while the model using the log-transformed predictor only has a single effect. If there is no theory to guide your model’s functional form, and the residuals from the polynomial and log-transformed models seem to fit equally well, then the log-transformed model saves you a degree of freedom, and probably should be adopted. Other Resources In addition to the notes and what we cover in class, there are many other resources for learning about log-transformations. Here are some resources that may be helpful in that endeavor: Interpreting Coefficients in Regression with Log-Transformed Variables Interpret Regression Coefficient Estimates "],
["nonlinearity-log-transforming-the-outcome.html", "Unit 3: Nonlinearity: Log-Transforming the Outcome 3.1 Dataset and Research Question 3.2 Examine Relationship between Age and Budget 3.3 Transform the Outcome Using the Natural Logarithm (Base-e) 3.4 Re-analyze using the Log-Transformed Budget 3.5 Interpreting the Regression Output 3.6 Plotting the Fitted Model 3.7 Relationship between MPAA Rating and Budget 3.8 Multiple Regression: Main Effects Model 3.9 Multiple Regression: Interaction Model", " Unit 3: Nonlinearity: Log-Transforming the Outcome In this set of notes, you will learn about log-transforming the outcome variable in a regression model to account for nonlinearity and heterogeneity of variance. Preparation Before class you will need to read the following: Osborne, Jason (2002). Notes on the use of data transformations. Practical Assessment, Research &amp; Evaluation, 8(6). 3.1 Dataset and Research Question The data we will use in this set of notes, movies.csv (see the data codebook here), includes attributes for \\(n=1,806\\) movies. # Load libraries library(broom) library(dplyr) library(ggplot2) library(readr) library(sm) library(tidyr) # Import data movies = read_csv(file = &quot;~/Documents/github/epsy-8252/data/movies.csv&quot;) head(movies) # A tibble: 6 x 4 title budget age mpaa &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; 1 &#39;Til There Was You 23 21 PG-13 2 10 Things I Hate About You 16 19 PG-13 3 100 Mile Rule 1.1 16 R 4 13 Going On 30 37 14 PG-13 5 13th Warrior, The 85 19 R 6 15 Minutes 42 17 R Using these data, we will examine the relationship between age of a movie and budget. 3.2 Examine Relationship between Age and Budget To being the analysis, we will examine the scatterplot between age and budget of our sample data. ggplot(data = movies, aes(x = age, y = budget)) + geom_point() + geom_smooth(se = FALSE) + theme_bw() + xlab(&quot;Movie age&quot;) + ylab(&quot;Movie Budget (in millions of dollars)&quot;) Figure 3.1: Scatterplot between age and budget. The loess smoother is also displayed. The scatterplot suggests two potential problems with fitting a linear model to the data: The relationship is slightly curvilinear. The variation in budget for more recent movies is much greater than the variation in budget for older movies (heteroskedasticity). We can see this much more clearly in the scatterplot of residuals versus fitted values from a fitted linear model. # Fit model lm.1 = lm(budget ~ 1 + age, data = movies) # Obtain residuals and fitted values out_1 = augment(lm.1) # Density plot of the residuals sm.density(out_1$.std.resid, model = &quot;normal&quot;, xlab = &quot;Standardized residuals&quot;) # Residuals versus fitted values ggplot(data = out_1, aes(x = .fitted, y = .std.resid)) + geom_point() + geom_hline(yintercept = 0) + geom_smooth() + theme_bw() + xlab(&quot;Fitted values&quot;) + ylab(&quot;Standardized residuals&quot;) Figure 3.2: Residual plots from regressing budget on age. These plots suggest violations of the normality assumption (the marginal distribution of the residuals is right-skewed) and of the assumption of homoskedasticity. Because of the large sample size, violation the linearity assumption is more difficult to see in this plot. 3.3 Transform the Outcome Using the Natural Logarithm (Base-e) To alleviate problems of non-normality when the conditional distributions are right-skewed (or have high-end outliers) OR to alleviate heteroskedasticity, we can mathematically transform the outcome using a logarithm. Any base can be used for the logarithm, but we will transform the outcome using the natural logarithm because of the interpretive value. First, we will create the log-transformed variable as a new column in the data, and then we will use the log-transformed budget (rather than raw budget) in any analyses. # Create log-transformed budget movies = movies %&gt;% mutate( Lbudget = log(budget) ) # Examine data head(movies) Recall that the logarithm is the inverse function of an exponent. As an example, consider the budget and log-transformed budget for ’Til There Was You. \\[ \\begin{split} \\ln(\\textrm{Budget}) &amp;= 3.135 \\\\ \\ln(23.0) &amp;= 3.135 \\\\ \\end{split} \\] Or, \\[ e^{3.135} = 23.0 \\] Remember, the logarithm answers the mathematical question: \\(e\\) to what power is equal to 23.0? 3.4 Re-analyze using the Log-Transformed Budget Now we will re-examine the scatterplot using the log-transformed outcome to see how this transformation affects the relationship. # Scatterplot ggplot(data = movies, aes(x = age, y = Lbudget)) + geom_point() + geom_smooth(se = FALSE) + theme_bw() + xlab(&quot;Movie age&quot;) + ylab(&quot;ln(Movie Budget)&quot;) Figure 3.3: Scatterplot between age and log-transformed budget. The loess smoother is also displayed. Log-transforming the outcome has drastically affected the scale for the outcome. Has this helped us better meet the assumptions? Again, we should examine the residual plots. # Fit model lm.2 = lm(Lbudget ~ 1 + age, data = movies) # Obtain residuals and fitted values out_2 = augment(lm.2) # Density plot of the residuals sm.density(out_2$.std.resid, model = &quot;normal&quot;, xlab = &quot;Standardized residuals&quot;) # Residuals versus fitted values ggplot(data = out_2, aes(x = .fitted, y = .std.resid)) + geom_point() + geom_hline(yintercept = 0) + geom_smooth() + theme_bw() + xlab(&quot;Fitted values&quot;) + ylab(&quot;Standardized residuals&quot;) Figure 3.4: Residual plots from regressing the natural logarithm of budget on age. These plots still suggest violations of the normality assumption (the marginal distribution of the residuals is now left-skewed). The assumption of homoskedasticity also seems still violated, although much less. Most importantly, however, is the assumption of linearity now seems satisfied. 3.5 Interpreting the Regression Output Let’s examine the output from the model in which we regressed the log-transformed budget on age. # Model-level output glance(lm.2) The model-level summary information suggests that differences in movies’ ages explains 2.1% of the variation in budget. (Remember, explaining variation in log-budget is the same as explaining variation in budget). Although this is a small amount of variation, it is statistically significant, \\(F(1,1804)=39.27\\), \\(p&lt;0.001\\). # Coefficient-level output tidy(lm.2) From the coefficient-level output the fitted equation is: \\[ \\ln\\left(\\hat{\\mathrm{Budget}_i}\\right) = 3.28 - 0.04(\\mathrm{Age}_i) \\] With log-transformations, there are two possible interpretations we can offer. The first is to interpret the coefficients using the log-transformed values. These we interpret in the exact same way we do any other regression coefficients (except we use log-outcome instead of outcome): The intercept, \\(\\hat{\\beta_0} = 3.28\\), is the average predicted log-budget for movies made in 2019 (Age = 0). The slope, \\(\\hat{\\beta_1} = -0.04\\), indicates that each one-year difference in age is associated with a log-budget that differ by \\(-0.04\\), on average. 3.5.1 Back-Transforming: A More Useful Interpretation A second, probably more useful, interpretation is to back-transform log-budget to budget. To think about how to do this, we first consider a more general expression of the fitted linear model: \\[ \\ln\\left(\\hat{Y}_i\\right) = \\hat\\beta_0 + \\hat\\beta_1(X_{i}) \\] The left-hand side of the equation is in the log-transformed metric, which drives our interpretations. If we want to instead, interpret using the raw metric of \\(Y\\), we need to back-transform from \\(\\ln(Y)\\) to \\(Y\\). To back-transform, we use the inverse function, which is to exponentiate using the base of the logarithm, in our case, base-\\(e\\). \\[ e^{\\ln(Y_i)} = Y_i \\] If we exponentiate the left-hand side of the equation, to maintain the equality, we also need to exponentiate the right-hand side of the equation. \\[ e^{\\ln(Y_i)} = e^{\\hat\\beta_0 + \\hat\\beta_1(X_{i})} \\] Then we use rules of exponents to simplify this. \\[ Y_i = e^{\\hat\\beta_0} \\times e^{\\hat\\beta_1(X_{i})} \\] For our example, when we exponentiate both sides of the fitted equation: \\[ \\hat{\\mathrm{Budget}_i} = e^{3.28} \\times e^{-0.04(\\mathrm{Age}_i)} \\] 3.5.2 Substituting in Values for Age to Interpret Effects To interpret the effects (which are now interpreted using budget—not log-budget) we can substitute in the different values for age and solve. For example when Age = 0: \\[ \\begin{split} \\hat{\\mathrm{Budget}_i} &amp;= e^{3.28} \\times e^{-0.04(0)}\\\\ &amp;= 26.58 \\times 1 \\\\ &amp;= 26.58 \\end{split} \\] The predicted budget for a movie made in 2019 is 26.58 million dollars. How about a movie that was made in 2018 (a one-year difference)? \\[ \\begin{split} \\hat{\\mathrm{Budget}_i} &amp;= e^{3.28} \\times e^{-0.04(1)}\\\\ &amp;= 26.58 \\times 0.96 \\\\ &amp;= 25.54 \\end{split} \\] The predicted budget for a movie made in 2019 is 25.54 million dollars. This is 0.96 TIMES the budget of a movie made in 2018. Rather than using the language of TIMES difference you could also use the language of fold difference. In this case the slope coefficient would be interpreted as, Each one-year difference in age is associated with a 0.95-fold difference in budget, on average. Simply put, when we back-transform from interpretations of log-\\(Y\\) to \\(Y\\) the interpretations are multiplicatively related to the intercept rather than additive. We can obtain these multiplicative values (and the back-transformed intercept) by using the exp() function to exponentiate the coefficients from the fitted model, which we obtain using the coef() function. exp(coef(lm.2)) (Intercept) age 26.5261 0.9569 3.5.3 Approximate Interpretation of the Slope Remember that by using the natural logarithm we can interpret the effects as percent change. Rather than saying that a movie made in 2018 is predicted to have a budget that is 0.96 TIMES that of a movie made in 2019, we can directly interpret the slope as the percent change. Thus \\(\\hat{\\beta_1}=-0.04\\) can be interpreted as: Each one-year difference in age is associated with a four percent decrease in budget, on average. If you want the specific mathematical change in budget, find \\(1 - e^{\\hat{\\beta_1}}\\). 1 - exp(-0.04) [1] 0.03921 If you use the language of percent decrease/increase, be very careful. Percent change and percentage change are sometimes interpreted differently! It is generally more clear to use the X-fold difference language. 3.6 Plotting the Fitted Model As always, we can plot the fitted model to aid in interpretation. To do this we will create a sequence of ages, predict the log-budget using the fitted model, and then back-transform the log-budgets to raw budget. # Set up data plot_data = crossing( age = seq(from = 13, to = 80, by = 1) ) %&gt;% mutate( # Predict yhat = predict(lm.2, newdata = .) ) # Examine data head(plot_data) # Back-transform the log-budgets plot_data = plot_data %&gt;% mutate( budget = exp(yhat) ) # Examine data head(plot_data) # Plot ggplot(data = plot_data, aes(x = age, y = budget)) + geom_line() + theme_bw() + xlab(&quot;Age&quot;) + ylab(&quot;Predicted budget (in millions of U.S. dollars)&quot;) Figure 3.5: Plot of the predicted movie budget as a function of its age. The non-linearity in the plot indicates that there is a diminishing negative effect of age on budget. Based on this plot, we see the non-linear, negative effect of age on budget. In other words, older movies tend to have a smaller budget, on average, but this decrease is not constant. This pattern of non-linear decline is referred to as exponential decay. Although this function has a different look than the function we saw in the previous unit (it is negative rather than positive), it is also a monotonic function (no change in direction). 3.7 Relationship between MPAA Rating and Budget We also may want to control for differences in MPAA rating. Before we fit the multiple regression model, however, we will first explore whether MPAA rating is a useful covariate by seeing whether there are differences in budget between PG, PG-13m and R rated movies. Since we log-transformed budget (the outcome) in the previous analysis we will need to use the log-transformed outcome in this exploration as well. # Plot the observed data ggplot(data = movies, aes(x = mpaa, y = Lbudget)) + geom_jitter(alpha = 0.2) + stat_summary(fun.y = &#39;mean&#39;, geom = &quot;point&quot;, size = 4, color = &quot;darkred&quot;) + theme_bw() + xlab(&quot;MPAA rating&quot;) + ylab(&quot;ln(Movie Budget)&quot;) Figure 3.6: Jittered scatterplot of log-budget versus MPAA rating. # Compute summary statistics movies %&gt;% group_by(mpaa) %&gt;% summarize( M = mean(Lbudget), SD = sd(Lbudget) ) The scatterplot and summary statistics indicate there are sample differences in the mean log-budgets for the three MPAA ratings. The variation in log-budgets seems roughly the same for the three ratings. 3.7.1 Regression Model Let’s regress log-transformed budget on MPAA rating and examine the output from the model. To do so, we will need to first create three dummy variables for the different ratings. # Create dummy variables movies = movies %&gt;% mutate( pg = if_else(mpaa == &quot;PG&quot;, 1, 0), pg13 = if_else(mpaa == &quot;PG-13&quot;, 1, 0), r = if_else(mpaa == &quot;R&quot;, 1, 0) ) # Fit the model (pg is reference group) lm.3 = lm(Lbudget ~ 1 + pg13 + r, data = movies) # Model-level output glance(lm.3) The model-level summary information suggests that differences in MPAA rating explains 8.9% of the variation in budget. (Remember, explaining variation in log-budget is the same as explaining variation in budget). Although this is a small amount of variation, it is statistically significant, \\(F(2,1803)=88.28\\), \\(p&lt;0.001\\). # Coefficient-level output tidy(lm.3) From the coefficient-level output we see that the fitted equation is: \\[ \\ln\\left(\\hat{\\mathrm{Budget}_i}\\right) = 2.88 + 0.26(\\mathrm{PG\\mbox{-}13}_i) - 0.87(\\mathrm{R}_i) \\] With log-transformations, there are two possible interpretations we can offer. The first is to interpret the coefficients using the log-transformed values. These we interpret in the exact same way we do any other regression coefficients (except we use log-outcome instead of outcome): The intercept, \\(\\hat{\\beta_0} = 2.88\\), is the average predicted log-budget for PG rated movies. The slope associated with PG-13, \\(\\hat{\\beta_1} = 0.26\\), indicates that PG-13 rated movies have a log-budget that is 0.26 higher than PG rated movies, on average. The slope associated with R, \\(\\hat{\\beta_2} = -0.87\\), indicates that R rated movies have a log-budget that is 0.87 lower than PG rated movies, on average. We can also interpret these by back-transforming to raw budget. To do that we exponentiate the coefficients. exp(coef(lm.3)) (Intercept) pg13 r 17.8134 1.2998 0.4201 PG rated movies have a budget of 17.81 million dollars, on average. PG-13 rated movies have a budget that is 1.30 TIMES the estimated budget for PG rated movies, on average. R rated movies have a budget that is 0.42 TIMES the estimated budget for PG rated movies, on average. 3.7.2 Mathematical Explanation Remember, if we want to interpret using the raw metric of \\(Y\\), we need to back-transform from \\(\\ln(Y)\\) to \\(Y\\). To back-transform, we use the inverse function, which is to exponentiate using the base of the logarithm, in our case, base-\\(e\\). For our example, when we exponentiate both sides of the fitted equation: \\[ \\begin{split} e^{\\ln\\left(\\hat{\\mathrm{Budget}_i}\\right)} &amp;= e^{2.88 + 0.26(\\mathrm{PG\\mbox{-}13}_i) - 0.87(\\mathrm{R}_i)} \\\\ \\hat{\\mathrm{Budget}_i} &amp;= e^{2.88} \\times e^{0.26(\\mathrm{PG\\mbox{-}13}_i)} \\times e^{-0.87(\\mathrm{R}_i)} \\end{split} \\] To interpret the effects (which are now interpreted using budget—not log-budget) we can substitute in the different dummy variable patterns and solve. \\[ \\begin{split} \\textbf{PG Movie:}~~ \\hat{\\mathrm{Budget}_i} &amp;= e^{2.88} \\times e^{0.26(0)} \\times e^{-0.87(0)}\\\\ &amp;= 17.81 \\times 1 \\times 1 \\\\ &amp;= 17.81 \\end{split} \\] \\[ \\begin{split} \\textbf{PG-13 Movie:}~~ \\hat{\\mathrm{Budget}_i} &amp;= e^{2.88} \\times e^{0.26(1)} \\times e^{-0.87(0)}\\\\ &amp;= 17.81 \\times 1.30 \\times 1 \\\\ &amp;= 23.15 \\end{split} \\] \\[ \\begin{split} \\textbf{R Movie:}~~ \\hat{\\mathrm{Budget}_i} &amp;= e^{2.88} \\times e^{0.26(0)} \\times e^{-0.87(1)}\\\\ &amp;= 17.81 \\times 1 \\times 0.42 \\\\ &amp;= 7.48 \\end{split} \\] 3.7.3 Approximate Interpretations Unfortunately, the approximate interpretations of the slopes by directly interpreting the coefficients using the language of percent change are not completely trustworthy. If we did interpret them, the interpretations for the two slopes would be: PG-13 rated movies have budget that is 26.2 percent higher than PG rated movies, on average. R rated movies have budget that is 87 percent lower than PG rated movies, on average. This interpretation is roughly true for the PG-13 effect, but not for the R effect. This approximate interpretation starts to become untrustworthy when the slope value is higher than about 0.20 or so. 3.8 Multiple Regression: Main Effects Model Now we can fit a model that includes our focal predictor of age and our covariate of MPAA rating. # Fit model (PG is reference group) lm.4 = lm(Lbudget ~ 1 + age + pg13 + r, data = movies) # Model-level output glance(lm.4) The model-level summary information suggests that differences in age and MPAA rating of a movie explains 11.0% of the variation in budget. (Remember, explaining variation in log-budget is the same as explaining variation in budget); \\(F(3,1802)=73.84\\), \\(p&lt;0.001\\). # Coefficient-level output tidy(lm.4) The coefficient-level output suggest that there is still a statistically significant effect of age on budget, after controlling for differences in MPAA rating; \\(t(1802)=-6.41\\), \\(p&lt;.001\\). To determine if there is an effect of MPAA rating, after accounting for differences in age, at least one of the effects of MPAA rating need to be statistically significant. Here we see that the coefficient associated with rated R movies is statistically significant. Remember that when we have more than two categories (more than one dummy variable) there can be many ways for the effect to play out, and not all of these are represented in the model we fitted. One way we can simultaneously examine ALL the ways this effect can play out is to use a nested \\(F\\)-test. 3.8.1 Nested F-Test If we want to examine if there is a controlled effect of MPAA rating (controlling for age), we want to see whether by including MPAA rating in a model THAT ALREADY INCLUDES age we explain additional variation in the outcome. To do this we can compare a model that only includes the effect of age to a model that includes both the effects of age and MPAA rating. If the latter model explains a statistically significant amount of additional variation we can say that there is an effect of MPAA rating after controlling for differences in age. In statistical hypothesis testing we are examining the following null hypothesis: \\[ H_0: \\rho^2_{\\mathrm{Age},\\mathrm{MPAA~rating}} - \\rho^2_{\\mathrm{Age}} = 0 \\] If we fail to reject this hypothesis, then the two models explain the SAME amount of variation and we should adopt the simpler model; MPAA rating does not explain additional variation in budget. If we reject this hypothesis, MPAA rating does explain additional variation in budget, above and beyond age; and we should adopt the model that includes both effects. To test this hypothesis we fit both models and then give both models to the anova() function. # Fit models lm.2 = lm(Lbudget ~ 1 + age, data = movies) lm.4 = lm(Lbudget ~ 1 + age + pg13 + r, data = movies) # Nested F-test anova(lm.2, lm.4) The test suggests that there is a statistically significant effect of MPAA rating even after accounting for differences in age; \\(F(2, 1802)=89.21\\), \\(p&lt;.001\\). 3.8.2 Coefficient-Level Interpretation To interpret the coefficients, we will again exponentiate the fitted coefficients so we can interpret them using the raw-metric of budget. exp(coef(lm.4)) (Intercept) age pg13 r 41.7120 0.9578 1.2318 0.4051 The model estimated budget for a PG movie (reference group) that was made in 2019 (age = 0) is 41.71 million dollars. Each one-year difference in age is associated with a 0.96-fold difference (4.3% decrease) in budget, on average, controlling for differences in MPAA rating. PG-13 rated movies have a budget that is 1.23 times that for PG movies, on average, controlling for differences in age. R rated movies have a budget that is 0.41 times that for PG movies, on average, controlling for differences in age. 3.8.3 Plot of the Fitted Model To plot the fitted model that includes a categorical predictor with more than two levels, it is best to re-fit the lm() using the categorical variable. # Re-fit the model lm.5 = lm(Lbudget ~ 1 + age + mpaa, data = movies) # Model-level output glance(lm.5) # Coefficient-level output tidy(lm.5) Note this is the exact same model we fitted using the dummy variables, but R will choose the reference group for us (alphabetically). We can now set up our plotting data, predict, back-transform the outcome, and plot. # Set up data plot_data = crossing( age = seq(from = 13, to = 80, by = 1), mpaa = c(&quot;PG&quot;, &quot;PG-13&quot;, &quot;R&quot;) ) %&gt;% mutate( yhat = predict(lm.5, newdata = .), budget = exp(yhat) ) # Examine data head(plot_data) # Plot ggplot(data = plot_data, aes(x = age, y = budget, color = mpaa, linetype = mpaa)) + geom_line() + theme_bw() + xlab(&quot;Age&quot;) + ylab(&quot;Predicted budget (in millions of U.S. dollars)&quot;) + ggsci::scale_color_d3(name = &quot;MPAA rating&quot;) + scale_linetype_manual(name = &quot;MPAA rating&quot;, values = 1:3) Figure 3.7: Plot of the predicted movie budget as a function of its age and MPAA rating. The non-linearity in the plot indicates that there is a diminishing negative effect of age on budget. The plot displays the negative, nonlinear effect of age on budget for all three types of movies (main effect of age). It also shows that PG-13 rated movies have a higher predicted budget than PG and R rated movies, and that PG rated movies have a higher predicted budget than R rated movies at EVERY age. This is the main effect of MPAA rating. Notice that in the plot, the three lines are not parallel. This is a mathematical artifact of back-transforming log-budget to raw budget. It does not indicate that an interaction model was fitted. How non-parallel the lines are depends on the size of the coefficients associated with the MPAA effects (in this example). This is why, especially with transformed data, it is essential to plot the model to make sure you are understanding the interpretations from your coefficients. 3.9 Multiple Regression: Interaction Model To study whether there is an interaction effect between MPAA rating and age, we will fit the interaction model and compare it to the main-effects model using the nested \\(F\\)-test. # Fit the models lm.5 = lm(Lbudget ~ 1 + age + mpaa, data = movies) lm.6 = lm(Lbudget ~ 1 + age + mpaa + age:mpaa, data = movies) # Nested F-test anova(lm.5, lm.6) The test suggests that we should adopt the main-effects model. The interaction-effect was not statistically significant; \\(F(2,1800)=1.41\\), \\(p=.244\\). If the model that included the interaction effect was adopted, it would suggest that: (1) the effect of age on budget depends on MPAA rating, or (2) the effect of MPAA rating on budget depends on age of the movie. To further interpret these effects, you should plot the results of the fitted interaction model. "],
["log-transformations-some-final-thoughts.html", "Log Transformations: Some Final Thoughts Power Transformations", " Log Transformations: Some Final Thoughts There are four general curvilinear, monotonic functions (shown below). Figure 3.8: Four general monotonic, curvilinear shapes. In the previous two units you learned how to transform the data to “linearize” two of the four monotonic functions: For positive, decelerating functions we log-transformed X; and For positive, accelerating functions we log-transformed Y. To better understand how we can use transformations to straighten-out relationships, we will examine a set of transformations known as power transformations. Power Transformations Consider a set of powers, \\(p\\) that can be used in the exponent of a variable \\(X\\) (the variable is irrelevant; it could also be \\(Y\\)) so that a transformation of the variable \\(X\\) is: \\[ \\mathrm{Transformed~Variable} = X^p \\] Consider the following values for \\(p\\): \\[ p = \\{-3,-2,-1,0,1,2,3\\} \\] These all represent particular transformations of \\(X\\). Note that when \\(p=1\\), the variable \\(X\\) is left untransformed (\\(X^1 = X\\)). Consider the following transformations: \\[ \\begin{split} &amp;X^3 \\\\ &amp;X^2 \\\\ &amp;X^1 \\qquad \\mathrm{Untransformed} \\end{split} \\] These are shown in the figure below. Power transformations that are bigger than 1 (\\(p&gt;1\\)) show positive acceleration. Powers larger than one are referred to as upward transformations as they increase the power (move it up) from one. Now consider these transformations: \\[ \\begin{split} &amp;X^{-1} \\\\ &amp;X^{-2} \\\\ &amp;X^{-3} \\end{split} \\] These are shown in the figure below. For power transformations that are smaller than 1 (\\(p&lt;1\\)), the function shows positive deceleration. Powers that are smaller than one are referred to as downward transformations as they decrease the power (move it down) from one. Ladder of Transformations If we order the different values of \\(p\\), they form what statisticians call a “ladder of re-expression” or “ladder of transformations”. \\[ \\begin{split} &amp; ~~~~~\\vdots \\\\ &amp;Y^3,X^3 &amp;\\qquad \\mathrm{Upward~Transformation}\\\\ &amp;Y^2,X^2 &amp;\\qquad \\mathrm{Upward~Transformation}\\\\ &amp;Y^1,X^1 &amp;\\qquad \\mathrm{Untransformed} \\\\ &amp;Y^{\\frac{1}{2}},X^{\\frac{1}{2}} &amp;\\qquad \\mathrm{Downward~Transformation}\\\\ &amp;Y^0,X^0 \\equiv \\ln(X) &amp;\\qquad \\mathrm{Downward~Transformation}\\\\ &amp;Y^{-1},X^{-1} &amp;\\qquad \\mathrm{Downward~Transformation}\\\\ &amp;Y^{-2},X^{-2} &amp;\\qquad \\mathrm{Downward~Transformation}\\\\ &amp;Y^{-3},X^{-3} &amp;\\qquad \\mathrm{Downward~Transformation} \\\\ &amp; ~~~~~\\vdots \\end{split} \\] Rule of the Bulge To determine how we need to transform data, we can rely on Mosteller and Tukey’s ‘Rule of the Bulge’. This rule, depicted visually below, has us “move on the ladder in the direction in which the bulge points”. Figure 3.9: Four general monotonic, curvilinear shapes. The Rule of the Bulge helps us identify how to transform the data to linearize any of these four shapes. For example, below we re-visit the mn-schools.csv data and again look at the relationship between median SAT score and six-year graduation rate. Figure 3.10: Scatterplot of the relationship between median SAT score and six-year graduation rate. The loess smoother is also displayed. This positive, decelerating relationship is similar to the one in the upper-lefthand quadrant of the ‘Rule of the Bulge’. To linearize this we can either: Transform \\(X\\) using a DOWNWARD transformation; or Transform \\(Y\\) using an UPWARD transformation. In the Unit 2 notes, we linearized this by taking the natural logarithm of SAT; a downward transformation of \\(X\\). What about the relationship between movie age and budget we looked at in Unit 3? Figure 3.11: Scatterplot between age and budget. The loess smoother is also displayed. This negative, decelerating relationship is similar to the one in the lower-lefthand quadrant of the ‘Rule of the Bulge’. To linearize this we can either: Transform \\(X\\) using a DOWNWARD transformation; or Transform \\(Y\\) using an DOWNWARD transformation. In the Unit 3 notes, we linearized this by taking the natural logarithm of budget; a downward transformation of \\(Y\\). By transforming \\(Y\\) instead of \\(X\\), we also fixed a problem of heterogeneity of variance; a problem in the residuals (which is related to \\(Y\\)). "],
["probability-distributions.html", "Unit 4: Probability Distributions 4.1 Dataset and Research Question 4.2 Normal Distribution 4.3 Student’s \\(t\\)-Distribution 4.4 Using the \\(t\\)-Distribution in Regression 4.5 Model-Level Inference: The \\(F\\)-Distribution 4.6 Mean Squares are Variance Estimates", " Unit 4: Probability Distributions In this set of notes, you will learn about common probability distributions. Preparation Before class you will need to do the following: Read Section 3.1.1: Probability Basics in Fox [Required Textbook] Read Sections 3.3.1–3.3.4 (Continuous Distributions) in Fox [Required Textbook] Refresh your knowledge about probability distributions by going though the Kahn Academy: Random Variables and Probability Distributions tutorial. 4.1 Dataset and Research Question In this set of notes, we will not be using a specific dataset. # Load libraries library(broom) library(dplyr) library(ggplot2) library(readr) library(sm) library(tidyr) 4.2 Normal Distribution The probability distribution of a normal distribution is mathematically defined as: \\[ p(x) = \\frac{1}{\\sigma\\sqrt{2\\pi}}\\exp\\left[-\\frac{(x-\\mu)^2}{2\\sigma^2}\\right] \\] for \\(-\\infty \\leq x \\leq \\infty\\). Consider a normal distribution with a mean (\\(\\mu\\)) of 50, and a standard deviation (\\(\\sigma\\)) of 10. We can compute the probability density (\\(p(x)\\)) for a particular \\(x\\) value by using this equation. For example, the probability density for \\(x=65\\) can be found using, \\[ p(65) = \\frac{1}{10\\sqrt{2\\pi}}\\exp\\left[-\\frac{(65-50)^2}{2\\times10^2}\\right] = 0.01295176 \\] Using R, we can carry out the computation, (1 / (10 * sqrt(2 * pi))) * exp(-(225) / 200) [1] 0.01295 There is also a more direct way to compute this using the dnorm() function. This function computes the density of x from a normal distribution with a specified mean and sd. dnorm(x = 65, mean = 50, sd = 10) [1] 0.01295 If we compute the density for several \\(x\\) values and plot them, we get the familiar normal shape; the graphical depiction of the mathematical equation. # Create dataset fig_01 = data.frame( X = seq(from = 10, to = 90, by = 0.01) ) %&gt;% rowwise() %&gt;% mutate( Y = dnorm(x = X, mean = 50, sd = 10) ) # Create plot ggplot(data = fig_01, aes(x = X, y = Y)) + geom_line() + theme_bw() + geom_point(x = 65, y = 0.01295176, size = 3) Figure 4.1: Plot of the probability density function (PDF) for a Normal distribution with mean of 50 and standard deviation of 10. The density value for \\(x=65\\), \\(p(65)= 0.01295176\\), is also displayed on the PDF. 4.2.1 Other Useful R Functions for Working with Probability Distributions There are four primary functions for working with the normal probability distribution: dnorm() : To compute the probability density (point on the curve) pnorm() : To compute the probability (area under the PDF) qnorm() : To compute the \\(x\\) value given a particular probability rnorm() : To draw a random observation from the distribution Each of these requires the arguments mean= and sd=. Let’s look at some of them in use. 4.2.2 Finding Cumulative Probability The function pnorm() gives the probability \\(x\\) is less than or equal to some quantile value in the distribution; the cumulative probability. For example, to find the probability that \\(x \\leq 65\\) we would use, pnorm(q = 65, mean = 50, sd = 10) [1] 0.9332 This is akin to finding the proportion of the area under the normal PDF that is to the left of 65. Figure 4.2: Plot of the PDF for a normal distribution (M=50, SD=10) with the cumulative probability for X less than or equal to 65 shaded. For the mathematically inclined, the grey-shaded area is expressed as an integral \\[ \\int_{-\\infty}^{65} p(x) dx \\] where \\(p(x)\\) is the PDF for the normal distribution. 4.2.3 Cumulative Density and \\(p\\)-Value This type of computation is used most commonly to find a \\(p\\)-value. The \\(p\\)-value is just the area under the distribution (curve) that is AT LEAST as extreme as some observed value. Consider a hypothesis test of whether a population parameter is equal to 0. Also consider that we observed a statistic (that has been standardized) of \\(z=2.5\\). Then, the \\(p\\)-value can be graphically displayed in the standard normal distribution as follows: Figure 4.3: Plot of the probability density function (PDF) for the standard normal distribution (M=0, SD=1). The cumulative density representing the p-value for a two-tailed test evaluating whether mu=0 using an observed z-value of 2.5 is also displayed. In most hypothesis tests, we test whether the parameter IS EQUAL to 0. Thus the values in the standard normal distribution more extreme than 2.5 encompass evidence against the hypothesis; those values greater than 2.5 and also those values less than \\(-2.5\\). (This is akin to testing a fair coin when both 8 heads OR 8 tails would provide evidence against fairness we have to consider evidence in both directions). To compute this we use pnorm(). Remember, it computes the proportion of the area under the curve TO THE LEFT of a particular value. Here we will compute the are to the left of \\(-2.5\\) and then double it to produce the actual \\(p\\)-value. 2 * pnorm(q = -2.5, mean = 0, sd = 1) [1] 0.01242 4.2.4 Finding Quantiles The qnorm() function is essentially the inverse of the pnorm() function. The p functions find the cumulative probability GIVEN a particular quantile. The q functions find the quantile GIVEN a cumulative probability. For example, in the normal distribution we defined earlier, half of the area is below the quantile value of 50 (the mean). qnorm(p = 0.5, mean = 50, sd = 10) [1] 50 4.3 Student’s \\(t\\)-Distribution Student’s \\(t\\)-distribution looks like a standard normal distribution. In the figure below, Student’s \\(t\\)-distribution is depicted with a solid, black line and the standard normal distribution (\\(M=0\\), \\(SD=1\\)) is depicted with a dotted, red line. Figure 4.4: Plot of the probability density function (PDF) for the standard normal distribution (dotted, red line) and Student’s t-distribution with 5 degrees of freedom (solid, black line). Both the standard normal distribution and Student’s \\(t\\)-distribution have a mean (expected value) of 0. The standard deviation for Student’s \\(t\\)-distribution is larger than the standard deviation for the standard normal distribution (\\(SD&gt;1\\)). You can see this in the distribution because the tails in Student’s \\(t\\)-distribution are fatter (more error) than the standard normal distribution. In practice, we often use Student’s \\(t\\)-distribution rather than the standard normal distribution when we are using sample data to estimate the population. This estimation increases the error and thus is typically modeled using Student’s \\(t\\)-distribution. Student’s \\(t\\)-distribution constitutes a family of distributions—not just a single distribution. The specific shape (and thus probability density) is defined by the degrees of freedom; df. The plot below shows the standard normal distribution (purple) and four \\(t\\)-distributions with varying df-values. Figure 4.5: Plot of several t-distributions with differing degrees of freedom. If we compare the means and SDs for these distributions, we find that the mean for all the \\(t\\)-distributions is 0, same as the standard normal distribution. All \\(t\\)-distributions are unimodal and symmetric around zero. The SD for every \\(t\\)-distribution is higher than the SD for the standard normal distribution. Student \\(t\\)-distributions with higher df values have less variation. It turns out that the standard normal distribution is a \\(t\\)-distribution with \\(\\infty\\) df. For the formula for the SD in a \\(t\\)-distribution, see Fox (2009). There are four primary functions for working with Student’s \\(t\\)-distribution: dt() : To compute the probability density (point on the curve) pt() : To compute the probability (area under the PDF) qt() : To compute the \\(x\\) value given a particular probability rt() : To draw a random observation from the distribution Each of these requires the arguments df=. Let’s look at some of them in use. 4.3.1 Comparing Probability Densities How do the probability densities for a value of \\(X\\) compare across these distributions? Let’s examine the \\(X\\) value of 2. # Standard normal distribution pnorm(q = 2, mean = 0, sd = 1) [1] 0.9772 # t-distribution with 3 df pt(q = 2, df = 3) [1] 0.9303 # t-distribution with 5 df pt(q = 2, df = 5) [1] 0.949 # t-distribution with 10 df pt(q = 2, df = 10) [1] 0.9633 # t-distribution with 25 df pt(q = 2, df = 25) [1] 0.9718 We are essentially comparing the height of these distributions at \\(X=2\\). Figure 4.6: Plot of several t-distributions with differing *degrees of freedom. The probability density for t=2 is also displayed for each of the distributions. 4.3.2 Comparing Cumulative Densities What if we wanted to look at cumulative density? Consider out hypothesis test of whether a population parameter is equal to 0. Also consider that we observed a statistic (that has been standardized) of 2.5 using a sample size of \\(n=15\\). If we can assume that the SAMPLING DISTRIBUTION is normally-distributed then we can use the cumulative density in a normal distribution to compute a \\(p\\)-value: 2 * pnorm(q = -2.5, mean = 0, sd = 1) [1] 0.01242 If, however, the SAMPLING DISTRIBUTION is \\(t\\)-distributed then we need to use the cumulative density for a \\(t\\)-distribution with the appropriate df to compute a \\(p\\)-value. For example if we use \\(df=n-1\\), the two-tailed \\(p\\)-value would be: 2 * pt(q = -2.5, df = 14) [1] 0.02547 The \\(p\\)-value using the \\(t\\)-distribution is larger than the \\(p\\)-value computed based on the standard normal distribution. This is again because of the increased error (uncertainty) we are introducing when we estimate from sample. This added uncertainty makes it harder for us to reject a hypothesis. 4.4 Using the \\(t\\)-Distribution in Regression To illustrate how probability distributions are used in practice, we will will use the riverview.csv (see the data codebook here) and fit a regression model that uses education level and seniority to predict variation in employee income. # Read in data city = read_csv(file = &quot;~/Documents/github/epsy-8252/data/riverview.csv&quot;) head(city) # Fit regression model lm.1 = lm(income ~ 1 + education + seniority, data = city) # Coefficient-level output tidy(lm.1) How do we obtain the \\(p\\)-value for each of the coefficients? Recall that the coefficients and SEs for the coefficients are computed directly from the raw data. Then we can compute a test-statistic by dividing the coefficient estimate by the SE. For example, to compute the test-statistic associated with education level: \\[ t = \\frac{2252}{335} = 6.72 \\] Since we are estimating the SE using sample data, our test statistic is likely \\(t\\)-distributed. Which value should we use for df? Well, for that, statistical theory tells us that we should use the error df value. In our data, \\[ \\begin{split} n &amp;= 32 \\\\ \\mathrm{Total~df} &amp;= 32-1 = 31\\\\ \\mathrm{Model~df} &amp;= 2~\\mathrm{(two~predictors)} \\\\ \\mathrm{Error~df} &amp;= 31-2 = 29 \\end{split} \\] Using the \\(t\\)-distribution with 29 df, 2 * pt(q = -6.72, df = 29) [1] 0.0000002257 For seniority (and the intercept), we would use the same \\(t\\)-distribution, but our test statistic would differ: \\[ \\begin{split} t_{\\mathrm{Intercept}} &amp;= \\frac{6769}{5373} = 1.26 \\\\ t_{\\mathrm{Seniority}} &amp;= \\frac{739}{210} = 3.52 \\\\ \\end{split} \\] The associated \\(p\\)-values are: # Intercept p-value 2 * pt(q = -1.26, df = 29) [1] 0.2177 # Seniority p-value 2 * pt(q = -3.52, df = 29) [1] 0.001446 4.5 Model-Level Inference: The \\(F\\)-Distribution The model-level inference for regression is based on an \\(F\\)-statistic, which is a standardized measure of \\(R^2\\). # Model-level output glance(lm.1) In this example, the sample \\(R^2\\) value is 0.742. Computation of the \\(F\\)-statistic relies on two df values—the model degrees of freedom (2) and the error degrees of freedom (29). To compute the \\(F\\)-statistics from \\(R^2\\) we use: \\[ F = \\frac{R^2}{1-R^2} \\times \\frac{\\mathrm{df}_{\\mathrm{Error}}}{\\mathrm{df}_{\\mathrm{Model}}} \\] In our example, we compute \\(F\\) as: \\[ \\begin{split} F &amp;= \\frac{0.742}{1-0.742} \\times \\frac{29}{2} \\\\ &amp;= 41.7 \\end{split} \\] We write this standardization of \\(R^2\\) as \\(F(2,29)=41.7\\). 4.5.1 Testing the Model-Level Null Hypothesis It is often worth testing whether the model explains a statistically significant amount of variation in the population. To do this we test the null hypothesis: \\[ H_0:\\rho^2 = 0 \\] Similar to the tests of the coefficients, we evaluate our test statistic (\\(F\\) in this case) in the appropriate test distribution, in this case an \\(F\\)-distribution with 2 and 29 degrees of freedom. (The shape of the \\(F\\)-distribution is based on two df values.) The figure below, shows the \\(F(2,29)\\)-distribution as a solid, black line. Figure 4.7: Plot of several F-distributions with differing degrees of freedom. The F(2,29)-distribution is shown as a solid, black line. The \\(F\\)-distribution, like the \\(t\\)-distribution is a family of distributions. They are positively skewed and generally have a lower-limit of 0. Because of this, when we use the \\(F\\)-distribution to compute a \\(p\\)-value, we only compute the cumulative density GREATER THAN OR EQUAL TO the value of the standardized test statistic. 4.5.1.1 Computing F from the ANOVA Partitioning We can also compute the model-level \\(F\\)-statistic using the partitioning of variation from the ANOVA table. anova(lm.1) The \\(F\\)-statistic is a ratio of the mean square for the model and the mean square for the error. To compute a mean square we use the general computation \\[ \\mathrm{MS} = \\frac{\\mathrm{SS}}{\\mathrm{df}} \\] The model includes both the education and seniority predictor, so we combine the SS and df. The MS model is: \\[ \\begin{split} \\mathrm{MS}_{\\mathrm{Model}} &amp;= \\frac{\\mathrm{SS}_{\\mathrm{Model}}}{\\mathrm{df}_{\\mathrm{Model}}} \\\\ &amp;= \\frac{4147330492 + 722883649}{1 + 1} \\\\ &amp;= \\frac{4870214141}{2} \\\\ &amp;= 2435107070 \\end{split} \\] The MS error is: \\[ \\begin{split} \\mathrm{MS}_{\\mathrm{Error}} &amp;= \\frac{\\mathrm{SS}_{\\mathrm{Error}}}{\\mathrm{df}_{\\mathrm{Error}}} \\\\ &amp;= \\frac{1695313285 }{29} \\\\ &amp;= 58459079 \\end{split} \\] Then, we compute the \\(F\\)-statistic by computing the ratio of these two mean squares. \\[ \\begin{split} F &amp;= \\frac{\\mathrm{MS}_{\\mathrm{Model}}}{\\mathrm{MS}_{\\mathrm{Error}}} \\\\ &amp;= \\frac{2435107070}{58459079} \\\\ &amp;= 41.7 \\end{split} \\] This is the observed \\(F\\)-statistic for the model. Note that this is an identical computation (although reframed) as the initial computation for \\(F\\). $$ \\begin{split} F &amp;= \\[1em] &amp;= \\[1em] &amp;= \\[1em] &amp;= \\[1em] &amp;= _{} \\[1em] &amp;= \\end{split} $$ To test the null hypothesis, \\(H_0:\\rho^2=0\\), we evaluate this observed \\(F\\)-statistic in an \\(F\\)-distribution with the 2 and 29 degrees of freedom. Figure 4.8: Plot of the probability density function (PDF) for the F-distribution with 2 and 29 degrees of freedom. The cumulative density representing the p-value for a two-tailed test evaluating whether rho-squared=0 using an observed F-statistic of 41.7 is also displayed. The computation using the cumulative density function, pf(), to obtain the \\(p\\)-value is: 1 - pf(41.7, df1 = 2, df2 = 29) [1] 0.000000002942 4.6 Mean Squares are Variance Estimates Mean squares are estimates of the variance. Consider the computational formula for the sample variance, \\[ \\hat{\\sigma}^2 = \\frac{\\sum(Y - \\bar{Y})^2}{n-1} \\] This is the total sum of squares divided by the total df. When we compute an \\(F\\)-statistic, we are finding the ratio of two different variance estimates—one based on the model (explained variance) and one based on the error (unexplained variance). Under the null hypothesis that \\(\\rho^2 = 0\\), we are assuming that all the variance is unexplained. In that case, our \\(F\\)-statistic would be close to zero. When the model explains a significant amount of variation, the numerator gets larger relative to the denominator and the \\(F\\)-value is larger. The mean squared error (from the anova() output) plays a special role in regression analysis. It is the variance estimate for the conditional distributions of the residuals in our visual depiction of the distributional assumptions of the residuals underlying linear regression. Figure 4.9: Visual depiction of the distributional assumptions of the residuals underlying linear regression. Recall that we made implicit assumptions about the conditional distributions of the residuals, namely that they were identically and normally distributed with a mean of zero and some variance. Based on the estimate of the mean squared error, the variance of each of these distributions is 58,459,079. While the variance is a mathematical convenience, the standard deviation is a better descriptor of the variation in these distributions. The standard deviation is 7646. sqrt(58459079) [1] 7646 We can also obtain this value from the model-level regression output. Here it is typically referred to as the Root Mean Squared Error (RMSE). In the glance() output this value is in the sigma column. glance(lm.1) Why is this value important? It gives the expected variation in the distribution. For example, since all of the conditional distributions of the residuals are normally distributed, we would expect that 95% of the residuals would fall between \\(\\pm2\\) standard errors from 0; or, in this case, between \\(-15292\\) and 15292. Observations with residuals that are more extreme may be regression outliers. References "],
["maximum-likelihood-estimation.html", "Unit 5: Maximum Likelihood Estimation 5.1 Dataset and Research Question 5.2 Joint Probability Density 5.3 Likelihood 5.4 Maximum Likelihood 5.5 Maximum Likelihood Estimation for Regression 5.6 ML Estimation in Regression Using R 5.7 Way, Way, Way too Much Mathematics", " Unit 5: Maximum Likelihood Estimation In this set of notes, you will learn about the method of maximum likelihood to estimate model parameters. Preparation Before class you will need read the following: Section 3.1.2: Random Variables in Fox [Required Textbook] Myung, J. (2003). Tutorial on maximum likelihood estimation. Journal of Mathematical Psychology, 47, 90–100. 5.1 Dataset and Research Question In this set of notes, we will not be using a specific dataset. # Load libraries library(broom) library(dplyr) library(ggplot2) library(readr) library(sm) library(tidyr) 5.2 Joint Probability Density In the previous set of notes, we discussed the probability density of an observation \\(X_i\\). Now we will extend this idea to the probability density of a set of observations, say \\(x_1\\), \\(x_2\\), AND \\(x_k\\). The probability density of a set of observations is referred to as the joint probability density, or simply joint density. If we can make an assumption about INDEPENDENCE, then the joint probability density would be the product of the individual densities: \\[ p(x_1, x_2, x_3, \\ldots, x_K) = p(x_1) \\times p(x_2) \\times p(x_3) \\times \\ldots \\times p(x_k) \\] Say we had three independent observations from our \\(\\sim\\mathcal{N}(50,10)\\) distribution, namely \\(x =\\{60, 65, 67\\}\\). Then the joint density would be, dnorm(x = 60, mean = 50, sd = 10) * dnorm(x = 65, mean = 50, sd = 10) * dnorm(x = 67, mean = 50, sd = 10) [1] 0.000002947 We could also shortcut this computation, prod(dnorm(x = c(60, 65, 67), mean = 50, sd = 10)) [1] 0.000002947 This value is the joint probability density. The joint probability density indicates the probability of observing the data (\\(x =\\{60, 65, 67\\}\\)) GIVEN (1) they are drawn from a normal distribution and (2) the normal distribution has a mean of 50 and a standard deviation of 10. In other words: The joint probability density is the probability of the data given the distribution and parameters. Symbolically, \\[ \\mathrm{Joint~Density} = P(\\mathrm{Data} \\mid \\mathrm{Distribution~and~Parameters}) \\] 5.3 Likelihood Likelihood is the probability of a particular set of parameters GIVEN (1) the data, and (2) the data are from a particular distribution (e.g., normal). Symbolically, \\[ \\mathrm{Likelihood} = P(\\mathrm{Parameters} \\mid \\mathrm{Distribution~and~Data}) \\] Likelihood takes the data as given and computes the probability of a set of parameters. Symbolically we denote likelihood with a scripted letter “L” (\\(\\mathcal{L}\\)). For example, we might ask the question, given the observed data \\(x = \\{30, 20, 24, 27\\}\\) come from a normal distribution, what is the likelihood (probability) that the mean is 20 and the standard deviation is 4? We might denote this as, \\[ \\mathcal{L}(\\mu = 20, \\sigma =4 \\mid x) \\] Note that although we need to specify the distribution (e.g., normal), this is typically not included in the symbolic notation; instead it is typically included in the assumptions. The likelihood allows us to answer probability questions about a set of parameters. For example, what is the likelihood (probability) that the data (\\(x = \\{30, 20, 24, 27\\}\\)) were generated from a normal distribution with a mean of 20 and standard deviation of 4? To compute the likelihood we compute the joint probability density of the data under that particular set of parameters. prod(dnorm(x = c(30, 20, 24, 27), mean = 20, sd = 4)) [1] 0.0000005703 What is the likelihood (probability) that the data (\\(x = \\{30, 20, 24, 27\\}\\)) were generated from a normal distribution with a mean of 25 and standard deviation of 4? prod(dnorm(x = c(30, 20, 24, 27), mean = 25, sd = 4)) [1] 0.00001774 It is important to note that although we use the joint probability under a set of parameters to compute the likelihood of those parameters, theoretically joint density and likelihood are very different. Likelihood refers to the probability of the parameters and joint probability density refers to the probability of the data. 5.4 Maximum Likelihood Which set of parameters,\\(\\mathcal{N}(20,4)\\) or \\(\\mathcal{N}(25,4)\\), was more likely to generate the given data? Since the second set of parameters produced a higher likelihood, the data was more likely to have been generated from the \\(\\mathcal{N}(25,4)\\) distribution that the \\(\\mathcal{N}(20,4)\\) distribution. So now we come to the crux of Maximum Likelihood Estimation (MLE). The goal of MLE is to find a set of parameters that MAXIMIZES the likelihood given the data and a distribution. For example, given the observed data \\(x = \\{30, 20, 24, 27\\}\\) were generated from a normal distribution, what are the values for the parameters of this distribution (mean and standard deviation) that produce the HIGHEST (or maximum) value of the likelihood? Below, we will examine a couple different methods for determining the parameter values that produce the maximum value of the likelihood. 5.4.1 Method 1: Grid Search One method for finding the parameters (in our example, the mean and standard deviation) that produce the maximum likelihood, is to substitute several parameter values in the dnorm() function, compute the likelihood for each set of parameters, and determine which set produces the highest (maximum) likelihood. In computer science, this method for finding the MLE is referred to as a grid search. Below is some syntax to carry out a grid search. The syntax creates several sets of parameter values (called the search space), computes the likelihood for each combination of parameter values, and then arranges the likelihoods in descending order. crossing( mu = seq(from = 10, to = 30, by = 0.1), sigma = seq(from = 0, to = 10, by = 0.1) ) %&gt;% rowwise() %&gt;% mutate( L = prod(dnorm(c(30, 20, 24, 27), mean = mu, sd = sigma)) ) %&gt;% arrange(desc(L)) The parameters that maximize the likelihood (in our search space) are a mean of 25.2 and a standard deviation of 3.7. 5.4.2 Log-Likelihood The likelihood values are quite small since we are multiplying several probabilities together. We could take the natural logarithm of the likelihood to alleviate this issue. So in our example, \\(\\mathcal{L} = .00001829129\\) and the log-likelihood would be log(.00001829129) [1] -10.91 We typically denote log-likelihood using a scripted lower-case “l” (\\(\\mathcal{l}\\)). Going back to how we compute the likelihood, we assumed a set of parameters and then found the joint probability density, which assuming normality and independence is the product of the individual densities. \\[ \\mathcal{L}(\\mathrm{parameters} | \\mathrm{data}) = p(x_1) \\times p(x_2) \\times \\ldots \\times p(x_n) \\] If we compute the log of the likelihood instead: \\[ \\mathcal{l}(\\mathrm{parameters} | \\mathrm{data}) = \\ln \\Bigl(\\mathcal{L}(\\mathrm{parameters} | \\mathrm{data})\\Bigr) = \\ln \\Bigl(p(x_1) \\times p(x_2) \\times \\ldots \\times p(x_n)\\Bigr) \\] Using the rules of logarithms, the right-hand side of the equation can be manipulated to: \\[ = \\ln \\Bigl(p(x_1)\\Bigr) + \\ln \\Bigl(p(x_2)\\Bigr) + \\ldots + \\ln \\Bigl(p(x_n)\\Bigr) \\] The log-likelihood is the sum of the log-transformed densities. This means we could re-write our grid search syntax to compute the log-likelihood. Since finding the log of the densities is so useful, there is even an argument in dnorm() of log=TRUE that does this for us. Our revised grid search syntax is: crossing( mu = seq(from = 10, to =30, by = 0.1), sigma = seq(from = 0, to = 10, by = 0.1) ) %&gt;% rowwise() %&gt;% mutate( log_L = sum(dnorm(c(30, 20, 24, 27), mean = mu, sd = sigma, log = TRUE)) ) %&gt;% arrange(desc(log_L)) Maximizing the log-likelihood gives the same parameter values as maximizing the likelihood. Remember that the log computation keeps the same ordination of values as the original data, so maximizing the log-likelihood is the same as maximizing the likelihood. 5.5 Maximum Likelihood Estimation for Regression In model fitting, the components we care about are the residuals. Those are the things we put distributional assumptions on (e.g., normality, homogeneity of variance, independence). Our goal in regression is to estimate a set of parameters (\\(\\beta_0\\), \\(\\beta_1\\)) that maximize the likelihood for a given set of residuals that come from a normal distribution. To understand this, let’s use a toy example of \\(n=10\\) observations. To begin, we can enter these observations into two vectors, \\(x\\) and \\(y\\). # Enter data into vectors x = c(4, 0, 3, 4, 7, 0, 0, 3, 0, 2) y = c(53, 56, 37, 55, 50, 36, 22, 75, 37, 42) Next, we will write a function to compute the log-likelihood (or likelihood) of the residuals given particular b0 and b1 estimates that will be inputted to the function. One issue is that in using the dnorm() function we need to specify the mean and standard deviation. The regression assumptions help with this task. The conditional mean residual value is 0. So we will set the mean value to 0. The assumption about the standard deviation is that the conditional distributions all have the same SD, but it doesn’t specify what that is. However, the SD of the errors seems like a reasonable value, so let’s use that. Below, we will write a function called log_likelihood() that takes two arguments as input, b0= and b1=, and outputs the log-likelihood. log_likelihood = function(b0, b1){ # Use the following x and y values x = c(4, 0, 3, 4, 7, 0, 0, 3, 0, 2) y = c(53, 56, 37, 55, 50, 36, 22, 75, 37, 42) # Compute the yhat and residuals based on the two input values yhats = b0 + b1*x errors = y - yhats # Compute the sd of the residuals sigma = sd(errors) # Compute the log-likelihood log_lik = sum(dnorm(errors, mean = 0, sd = sigma, log = TRUE)) # Output the log-likelihood return(log_lik) } Now we read in our function by highlighting the whole thing and running it. Once it has been read in, we can use it just like any other function. For example to find the log-likelihood for the parameters \\(\\beta_0=10\\) and \\(\\beta_1=3\\) we use: log_likelihood(b0 = 10, b1 = 3) [1] -64.29 We can also use our function in a grid search. crossing( b0 = seq(from = 30, to = 50, by = 0.1), b1 = seq(from = -5, to = 5, by = 0.1) ) %&gt;% rowwise() %&gt;% mutate( log_L = log_likelihood(b0 = b0, b1 = b1) ) %&gt;% arrange(desc(log_L)) Here the parameter values that maximize the likelihood are \\(\\beta_0 = 40.1\\) and \\(\\beta_1=2.7\\). We can also compute what the standard deviation for the residual distributions was using the estimated parameter values. Remember, this value is an estimate of the RMSE. errors = y - 40.1 - 2.7*x sd(errors) [1] 13.19 In practice, there are a couple subtle differences, namely that the estimate for the SD value we use in dnorm() is slightly different. This generally does not have an effect on the coefficient estimates, but does impact the estimate of the RMSE. We will talk more about this when we talk about Restricted Maximum Likelihood Estimation (REML). 5.5.1 Large Search Spaces So far, we have been using a very finite search space that has been defined for us. For example, we limited the search space to 20,301 combinations of \\(\\beta_0\\) and \\(\\beta_1\\). nrow( crossing( b0 = seq(from = 30, to = 50, by = 0.1), b1 = seq(from = -5, to = 5, by = 0.1) ) ) [1] 20301 This allowed us to find the coefficient estimates to the nearest tenth. If we instead needed to find the estimates to the nearest hundredth, we would need to expand the number of combinations: nrow( crossing( b0 = seq(from = 30, to = 50, by = 0.01), b1 = seq(from = -5, to = 5, by = 0.01) ) ) [1] 2003001 This leads to a search space of 2,003,001 parameter combinations. If we need them to the nearest thousandth, the search space is 200,030,001 combinations. Furthermore, in practice you would not have any idea which values of \\(\\beta_0\\) and \\(\\beta_1\\) to limit the search space to. Essentially you would need to search an infinite number of values unless you could limit the search space in some way. For many common methods (e.g., linear regression) finding the ML estimates is mathematically pretty easy (if we know calculus; see the section Way, Way, Way too Much Mathematics). For more complex methods (e.g., mixed-effect models) there is not a mathematical solution. Instead, mathematics is used to help limit the search space and then a grid search is used to hone in on the estimates. 5.6 ML Estimation in Regression Using R Recall that the lm() function uses Ordinary Least Squares (OLS) estimation—it finds the coefficient estimates and RMSE that minimize the sum of squared residuals. lm.1 = lm(y ~ 1 + x) # Get coefficient estimates tidy(lm.1) # Get estimate for RMSE glance(lm.1) Under OLS estimation: \\(\\hat\\beta_0 = 40.01\\) \\(\\hat\\beta_1 = 2.74\\) \\(\\hat\\sigma_\\epsilon = 13.99\\) To compute ML estimates of the coefficients we will use the mle2() function from the bbmle package. To use the mle2() function, we need to provide a user-written function that returns the negative log-likelihood given a set of parameter inputs. For simple regression, recall that we need to estimate three parameters: \\(\\beta_0\\), \\(\\beta_1\\), and \\(\\sigma_{\\epsilon}\\) (RMSE). Below we have a function that inputs values for each of the three parameters, uses the inputted coefficient values to compute the residuals given the data, and returns the negative log-likelihood value assuming normality, independence, and homoscedasticity. regress.ll = function(b0, b1, rmse) { # Use the following x and y values x = c(4, 0, 3, 4, 7, 0, 0, 3, 0, 2) y = c(53, 56, 37, 55, 50, 36, 22, 75, 37, 42) # Compute yhats and residuals yhats = b0 + b1 * x errors = y - yhats # Compute the negative log-likelihood neg_log_L = -sum(dnorm(errors, mean = 0, sd = rmse, log = TRUE)) return(neg_log_L) } Now we can implement the mle2() function. This function requires the argument, minuslogl=, which takes the user written function returning the negative log-likelihood. It also requires a list of starting values for the input parameters in the user-written function. (Here we give values close to the OLS estimates as starting values.) # Fit model using ML library(bbmle) mle.results = mle2(minuslogl = regress.ll, start = list(b0 = 40.0, b1 = 2.7, rmse = 13.98)) # View results summary(mle.results) Maximum likelihood estimation Call: mle2(minuslogl = regress.ll, start = list(b0 = 40, b1 = 2.7, rmse = 13.98)) Coefficients: Estimate Std. Error z value Pr(z) b0 40.01 5.67 7.05 1.7e-12 *** b1 2.74 1.77 1.55 0.12 rmse 12.51 2.80 4.47 7.7e-06 *** --- Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 -2 log L: 78.91 Under ML estimation: \\(\\hat\\beta_0 = 40.01\\) \\(\\hat\\beta_1 = 2.74\\) \\(\\hat\\sigma_\\epsilon = 12.51\\) Comparing the coefficient estimates (\\(\\hat\\beta_0\\) and \\(\\hat\\beta_1\\)) between the two methods of estimation, we find they are quite similar. The estimate of \\(\\sigma_{\\epsilon}\\) is different between the two estimation methods (although they are somewhat close in value). Why do the estimates of the RMSE differ depending on the method of estimation? This is because the two methods use different formulas for computing RMSE. In OLS estimation, recall that the estimate of \\(\\hat\\sigma_\\epsilon\\) was: \\[ \\hat\\sigma_{\\epsilon}=\\frac{\\left(Y_i - \\hat{Y}_i\\right)^2}{n-2}, \\] For ML estimation, the estimate for \\(\\hat\\sigma_\\epsilon\\) is: \\[ \\hat\\sigma_{\\epsilon}=\\frac{\\left(Y_i - \\hat{Y}_i\\right)^2}{n}, \\] The smaller denominator in OLS results in a higher estimate of the variation. This, in turn, affects the size of the SE estimates for the coefficients (and thus the \\(t\\)- and \\(p\\)-values). When \\(n\\) is large, the differences in the estimates of \\(\\hat\\sigma_\\epsilon\\) are minimal and can safely be ignored. Lastly, we note that the value of \\(-2\\)(log-likelihood) is the same for both the ML and OLS estimated models. This is a useful result. It allows us to use lm() to estimate the coefficients from a model and then use its log-likelihood as if we had fitted the model using ML. 5.6.1 Using R to Directly Compute the Likelihood and Log-Likelihood We can use R to directly compute the log-likelihood after we fit a model using the lm() function. To do this, we use the logLik() function. lm.1 = lm(y ~ 1 + x) logLik(lm.1) &#39;log Lik.&#39; -39.45 (df=3) To compute the likelihood, we can use the exp() function to back-transform the log-likelihood to the likelihood (although generally we will work with the log-likelihood). exp(-39.45442) [1] 7.331e-18 5.7 Way, Way, Way too Much Mathematics A second, more convenient method to determine the ML estimates of the regression parameters is to use mathematics; specifically calculus. Remember, we can express the likelihood of the regression residuals mathematically as: \\[ \\mathcal{L}(\\beta_0, \\beta_1 | \\mathrm{data}) = p(\\epsilon_1) \\times p(\\epsilon_2) \\times \\ldots \\times p(\\epsilon_n) \\] where the probability density of each residual (assuming normality) is: \\[ p(\\epsilon_i) = \\frac{1}{\\sigma\\sqrt{2\\pi}}\\exp\\left[-\\frac{(\\epsilon_i-\\mu)^2}{2\\sigma^2}\\right] \\] In addition to normality, which gives us the equation to compute the PDF for each residual, the regression assumptions also specify that each conditional error distribution has a mean of 0 and some variance (that is the same for all conditional error distributions). We can call it \\(\\sigma^2_{\\epsilon}\\). Substituting these values into the density function, we get, \\[ \\begin{split} p(\\epsilon_i) &amp;= \\frac{1}{\\sigma_{\\epsilon}\\sqrt{2\\pi}}\\exp\\left[-\\frac{(\\epsilon_i-0)^2}{2\\sigma^2_{\\epsilon}}\\right] \\\\[1em] &amp;= \\frac{1}{\\sigma_{\\epsilon}\\sqrt{2\\pi}}\\exp\\left[-\\frac{(\\epsilon_i)^2}{2\\sigma^2_{\\epsilon}}\\right] \\end{split} \\] Now we use this expression for each of the \\(p(\\epsilon_i)\\) values in the likelihood computation. \\[ \\begin{split} \\mathcal{L}(\\beta_0, \\beta_1 | \\mathrm{data}) &amp;= p(\\epsilon_1) \\times p(\\epsilon_2) \\times \\ldots \\times p(\\epsilon_n) \\\\[1em] &amp;= \\frac{1}{\\sigma_{\\epsilon}\\sqrt{2\\pi}}\\exp\\left[-\\frac{\\epsilon_1 ^2}{2\\sigma^2_{\\epsilon}}\\right] \\times \\frac{1}{\\sigma_{\\epsilon}\\sqrt{2\\pi}}\\exp\\left[-\\frac{\\epsilon_2^2}{2\\sigma^2_{\\epsilon}}\\right] \\times \\ldots \\times \\frac{1}{\\sigma_{\\epsilon}\\sqrt{2\\pi}}\\exp\\left[-\\frac{\\epsilon_n^2}{2\\sigma^2_{\\epsilon}}\\right] \\end{split} \\] We can simplify this: \\[ \\begin{split} \\mathcal{L}(\\beta_0, \\beta_1 | \\mathrm{data}) &amp;=\\left[ \\frac{1}{\\sigma_{\\epsilon}\\sqrt{2\\pi}} \\right]^n \\times \\exp\\left[-\\frac{\\epsilon_1^2}{2\\sigma^2_{\\epsilon}}\\right] \\times \\exp\\left[-\\frac{\\epsilon_2^2}{2\\sigma^2_{\\epsilon}}\\right] \\times \\ldots \\times \\exp\\left[-\\frac{\\epsilon_n^2}{2\\sigma^2_{\\epsilon}}\\right] \\end{split} \\] Now we will take the natural logarithm of both sides of the expression: \\[ \\begin{split} \\ln \\Bigl(\\mathcal{L}(\\beta_0, \\beta_1 | \\mathrm{data})\\Bigr) &amp;= \\ln \\Biggl( \\left[ \\frac{1}{\\sigma_{\\epsilon}\\sqrt{2\\pi}} \\right]^n \\times \\exp\\left[-\\frac{\\epsilon_1^2}{2\\sigma^2_{\\epsilon}}\\right] \\times \\exp\\left[-\\frac{\\epsilon_2^2}{2\\sigma^2_{\\epsilon}}\\right] \\times \\ldots \\times \\exp\\left[-\\frac{\\epsilon_n^2}{2\\sigma^2_{\\epsilon}}\\right] \\Biggr) \\\\ \\end{split} \\] Using our rules for logarithms and re-arranging gives, \\[ \\mathcal{l}(\\beta_0, \\beta_1 | \\mathrm{data}) = -\\frac{n}{2} \\times \\ln (2\\pi\\sigma^2_{\\epsilon}) - \\frac{1}{2\\sigma^2_{\\epsilon}} \\times \\sum \\epsilon_i^2 \\] Examining this equation, we see that the log-likelihood is a function of \\(n\\), \\(\\sigma^2_{\\epsilon}\\) and the sum of squared residuals (SSE). The observed data define \\(n\\) (the sample size) and the other two components come from the residuals which are a function of the parameters and the data. Once we have this function, calculus can be used to find the analytic maximum. Typically before we do this, we replace \\(\\epsilon_i\\) with \\(Y_i - \\hat\\beta_0 - \\hat\\beta_1(X_i)\\); writing the residuals as a function of the parameters (which we are solving for) and the data. \\[ \\mathcal{l}(\\beta_0, \\beta_1 | \\mathrm{data}) = -\\frac{n}{2} \\times \\ln (2\\pi\\sigma^2_{\\epsilon}) - \\frac{1}{2\\sigma^2_{\\epsilon}} \\times \\sum \\bigg(Y_i - \\hat\\beta_0 - \\hat\\beta_1(X_i)\\bigg)^2 \\] To find the analytic maximum, we compute the partial derivatives with respect to \\(\\hat\\beta_0\\) and \\(\\hat\\beta_1\\), and set these equal to zero. This gives us a system of two equations with two unknowns (\\(\\hat\\beta_0\\) and \\(\\hat\\beta_1\\)). We can then solve this set of equations to obtain each of the parameter estimates. Then, based on these values, we can compute the estimate for the RMSE. "],
["information-criteria-for-model-selection.html", "Unit 6: Information Criteria for Model Selection 6.1 Dataset and Research Question 6.2 Model-Building 6.3 Candidate Statistical Models 6.4 Log-Likelihood 6.5 Deviance: An Alternative Fit Value 6.6 Akiake’s Information Criteria (AIC) 6.7 Empirical Support for Hypotheses", " Unit 6: Information Criteria for Model Selection In this set of notes, you will learn about using information criteria to select a model from a set of candidate models. Preparation Before class you will need read the following: Elliott, L. P., &amp; Brook, B. W. (2007). Revisiting Chamberlin: Multiple working hypotheses for the 21st century. BioScience, 57(7), 608–614. 6.1 Dataset and Research Question In this set of notes, we will use the data in the ed-schools-2018.csv file (see the data codebook here). These data include institutional-level attributes for several graduate education schools/programs rated by U.S. News and World Report in 2018. # Load libraries library(broom) library(corrr) library(dplyr) library(ggplot2) library(readr) library(sm) library(tidyr) # Read in data ed = read_csv(file = &quot;~/Documents/github/epsy-8252/data/ed-schools-2018.csv&quot;) head(ed) # A tibble: 6 x 13 rank school score peer expert_score gre_verbal gre_quant doc_accept &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 1 Harva… 100 4.4 4.6 163 159 4.5 2 2 Stanf… 99 4.6 4.8 162 160 6.1 3 3 Unive… 96 4.2 4.3 156 152 29.1 4 3 Unive… 96 4.1 4.5 163 157 5 5 3 Unive… 96 4.3 4.5 155 153 26.1 6 6 Johns… 95 4.1 4.1 164 162 27.4 # … with 5 more variables: phd_student_faculty_ratio &lt;dbl&gt;, # phd_granted_per_faculty &lt;dbl&gt;, funded_research &lt;dbl&gt;, # funded_research_per_faculty &lt;dbl&gt;, enroll &lt;dbl&gt; Using these data, we will examine the factors our academic peers use to rate graduate programs. To gather the peer assessment data, U.S. News asked deans, program directors and senior faculty to judge the academic quality of programs in their field on a scale of 1 (marginal) to 5 (outstanding). Based on the substantive literature we have three scientific working hypotheses about how programs are rated: H1: Student-related factors drive the perceived academic quality of graduate programs in education. H2: Faculty-related factors drive the perceived academic quality of graduate programs in education. H3: Institution-related factors drive the perceived academic quality of graduate programs in education. We need to translate these working hypotheses into statistical models that we can then fit to a set of data. The models are only proxies for the working hypotheses. However, that being said, the validity of using the models as proxies is dependent on whether we have measured well, whether the translation makes substantive sense given the literature base, etc. Here is how we are measuring the different attributes: The student-related factors we will use are GRE scores. The faculty-related factors we will use are funded research (per faculty member) and the number of Ph.D. graduates (per faculty member). The institution-related factors we will use are the acceptance rate of Ph.D. students, the Ph.D. student-to-faculty ratio, and the size of the program. 6.2 Model-Building Before we begin the exploratory analysis associated with model-building, it is worth noting that there are missing data in the dataset. summary(ed) rank school score peer Min. : 1.0 Length:129 Min. : 38.0 Min. :2.50 1st Qu.: 32.0 Class :character 1st Qu.: 42.0 1st Qu.:2.90 Median : 62.0 Mode :character Median : 51.0 Median :3.20 Mean : 63.2 Mean : 55.3 Mean :3.29 3rd Qu.: 93.0 3rd Qu.: 63.0 3rd Qu.:3.60 expert_score gre_verbal gre_quant doc_accept Min. :2.40 Min. :148 Min. :142 Min. : 4.5 1st Qu.:3.30 1st Qu.:152 1st Qu.:148 1st Qu.: 25.8 Median :3.60 Median :154 Median :150 Median : 39.8 Mean :3.64 Mean :155 Mean :151 Mean : 41.4 3rd Qu.:4.00 3rd Qu.:156 3rd Qu.:153 3rd Qu.: 54.1 phd_student_faculty_ratio phd_granted_per_faculty funded_research Min. : 0.00 Min. :0.000 Min. : 0.10 1st Qu.: 1.70 1st Qu.:0.400 1st Qu.: 3.75 Median : 2.60 Median :0.600 Median : 8.00 Mean : 2.91 Mean :0.745 Mean :13.84 3rd Qu.: 3.70 3rd Qu.:0.900 3rd Qu.:18.10 funded_research_per_faculty enroll Min. : 2.9 Min. : 29 1st Qu.: 78.5 1st Qu.: 556 Median : 163.4 Median : 835 Mean : 226.2 Mean : 954 3rd Qu.: 266.8 3rd Qu.:1281 [ reached getOption(&quot;max.print&quot;) -- omitted 2 rows ] This is a problem when we are comparing models that use different variables as the observations used to fit one model will be different than the observations used to fit another model. Since we are going to be using a likelihood-based method of comparing the models, this is problematic. Remember, likelihood-based methods find us the most likely model given a set of data. If the datasets used are different, we won’t know whether a model with a higher likelihood is truly more likely or is more likely because of the dataset used. To alleviate this problem, we will eliminate any observations (rows in the dataset) that have missing data. This is called listwise or row-wise deletion. Any analyses performed on the remaining data constitute a complete-cases analysis, since these cases have no missing data. To select the complete cases, we will use the drop_na() function from the tidyr package. # Drop rows with missing data educ = ed %&gt;% drop_na() # Check resulting data nrow(educ) [1] 122 summary(educ) rank school score peer Min. : 1.0 Length:122 Min. : 38.0 Min. :2.50 1st Qu.: 31.2 Class :character 1st Qu.: 43.0 1st Qu.:2.90 Median : 59.5 Mode :character Median : 51.5 Median :3.20 Mean : 60.5 Mean : 56.2 Mean :3.31 3rd Qu.: 89.0 3rd Qu.: 63.8 3rd Qu.:3.60 expert_score gre_verbal gre_quant doc_accept Min. :2.40 Min. :148 Min. :142 Min. : 4.5 1st Qu.:3.30 1st Qu.:152 1st Qu.:148 1st Qu.:25.5 Median :3.60 Median :154 Median :150 Median :38.6 Mean :3.66 Mean :155 Mean :151 Mean :40.1 3rd Qu.:4.00 3rd Qu.:156 3rd Qu.:153 3rd Qu.:51.6 phd_student_faculty_ratio phd_granted_per_faculty funded_research Min. : 0.00 Min. :0.000 Min. : 0.10 1st Qu.: 1.70 1st Qu.:0.400 1st Qu.: 3.85 Median : 2.70 Median :0.650 Median : 8.50 Mean : 2.94 Mean :0.758 Mean :14.26 3rd Qu.: 3.77 3rd Qu.:0.900 3rd Qu.:18.82 funded_research_per_faculty enroll Min. : 2.9 Min. : 29 1st Qu.: 77.8 1st Qu.: 562 Median : 160.6 Median : 842 Mean : 228.8 Mean : 970 3rd Qu.: 283.4 3rd Qu.:1312 [ reached getOption(&quot;max.print&quot;) -- omitted 1 row ] After selecting the complete-cases, the usable, analytic sample size is \\(n=122\\). Seven observations (5.4%) were eliminated from the original sample because of missing data. 6.2.1 Exploration of the Outcome The outcome variable we will use in each of the models is peer rating (peer). This variable can theoretically vary from 1 to 5, but in our sample has only ranges from 2.5 to 4.6. The density plot indicates that this variable is right-skewed. This may foreshadow problems meeting the normality assumption and we subsequently may consider log-transforming this variable. Figure 6.1: Density plot of the outcome variable used in the different models. Below we show scatterplots of the outcome (peer ratings) versus each of the predictors we are considering in the three scientific models. Figure 6.2: Scatterplots of peer ratings versus the student-related factors; verbal and quantitative GRE scores. The loess smoother is also displayed. Figure 6.3: Scatterplots of peer ratings versus the faculty-related factors; funded research (per faculty member) and number of Ph.D.s granted (per faculty member). The loess smoother is also displayed. Figure 6.4: Scatterplots of peer ratings versus the institution-related factors; acceptance rate of Ph.D. students, the Ph.D. student-to-faculty ratio, and the size of the program. The loess smoother is also displayed. Almost all of these plots show curvilinear patterns, some of which can be alleviated by log-transforming the outcome. Remember, log-transforming the outcome will also help with violations of homoskedasticity. Since we want to be able to compare the models at the end of the analysis, we NEED to use the same outcome in each of the models. Given the initial right-skewed nature of the outcome distribution and the evidence from the scatterplots, we will log-transform peer ratings and use that outcome in each model we fit. # Create log-transformed peer ratings educ = educ %&gt;% mutate( Lpeer = log(peer) ) 6.2.2 Building the Student-Related Factors Model To determine which of the student-related factors to include in the model, we will examine the scatterplots of each predictor against the log-transformed peer ratings and also examine the correlation matrix of the outcome and student-related predictors. Figure 6.5: Scatterplots of the log-transformed peer ratings versus the student-related factors; verbal and quantitative GRE scores. The loess smoother is also displayed. educ %&gt;% select(Lpeer, gre_verbal, gre_quant) %&gt;% correlate() Not surprisingly, the mean GRE verbal and GRE quantitative scores are highly correlated. Since including highly correlated predictors in a model can lead to unstable estimates, we will drop one of the predictors from the model. Empirically, the quantitative GRE scores seem more highly correlated with the outcome, so we will drop the GRE verbal scores from the model. Focusing on the scatterplot of the GRE quantitative scores, the relationship with the log-transformed peer ratings looks curvilinear (non-monotonic). The empirical relationship seems to change direction twice, indicating that log-transformed peer ratings may be a cubic-function of the quantitative GRE scores. # Fit cubic model lm.1 = lm(Lpeer ~ 1 + gre_quant + I(gre_quant^2) + I(gre_quant^3), data = educ) # Coefficient-level output tidy(lm.1) # Obtain residuals out_1 = augment(lm.1) # Examine residuals sm.density(out_1$.std.resid, xlab = &quot;Standardized residuals&quot;, model = &quot;normal&quot;) ggplot(data = out_1, aes(x = .fitted, y = .std.resid)) + geom_point() + geom_hline(yintercept = 0) + theme_bw() + xlab(&quot;Fitted values&quot;) + ylab(&quot;Standardized residuals&quot;) Figure 6.6: Residual plots for the fitted model using the student-related factors. 6.2.3 Building the Faculty-Related Factors Model To determine which of the faculty-related factors to include in the model, we will examine the scatterplots of each predictor against the log-transformed peer ratings and also examine the correlation matrix of the outcome and faculty-related predictors. Figure 6.7: Scatterplots of log-transformed peer ratings versus the faculty-related factors; funded research (per faculty member) and number of Ph.D.s granted (per faculty member). The loess smoother is also displayed. educ %&gt;% select(Lpeer, funded_research_per_faculty, phd_granted_per_faculty) %&gt;% correlate() The two predictors are moderately correlated with each other and both are correlated with the outcome. The scatterplot of peer ratings versus funded research suggest a monotonic curvilinear relationship. The Rule of the Bulge indicates that log-transforming the predictor may help linearize this relationship. The scatterplot of peer ratings versus number of Ph.D.s granted suggests that the distribution of the predictor is right-skewed with a potential outlying observation. This relationship may also benefit from log-transforming the predictor. Before log-transforming these predictors, it is a good idea to check the distributions for zero or negative values. educ %&gt;% select(funded_research_per_faculty, phd_granted_per_faculty) %&gt;% summary() funded_research_per_faculty phd_granted_per_faculty Min. : 2.9 Min. :0.000 1st Qu.: 77.8 1st Qu.:0.400 Median : 160.6 Median :0.650 Mean : 228.8 Mean :0.758 3rd Qu.: 283.4 3rd Qu.:0.900 Max. :1239.1 Max. :8.400 The summary values for the phd_granted_per_faculty predictor indicates that there are some schools that have a value of 0 for this predictor and that 0 is the smallest value. Before we transform using a log-transformation, we need to make it so the smallest value in the predictor is 1, since the log of 0 (and any negative values) is undefined. To do this we will add some number (in our case 1) to each value for phd_granted_per_faculty prior to taking the log. #Create log of the faculty-related predictors educ = educ %&gt;% mutate( Lfunded_research_per_faculty = log(funded_research_per_faculty), Lphd_granted_per_faculty = log(phd_granted_per_faculty + 1) ) Figure 6.8: Scatterplots of log-transformed peer ratings versus the log-transformed faculty-related factors; funded research (per faculty member) and number of Ph.D.s granted (per faculty member). The loess smoother is also displayed. Although this helped, it did not “cure” the nonlinearity. We might want to further include a quadratic term for each of the predictors. To evaluate this, we will fit the model that includes the linear and quadratic log-transformed predictors and examine the coefficient-level output and residuals. # Fit model lm.2 = lm(Lpeer ~ 1 + Lfunded_research_per_faculty + I(Lfunded_research_per_faculty^2) + Lphd_granted_per_faculty + I(Lphd_granted_per_faculty^2), data = educ) # Coefficient-level output tidy(lm.2) # Obtain residuals out_2 = augment(lm.1) # Examine residuals sm.density(out_2$.std.resid, xlab = &quot;Standardized residuals&quot;, model = &quot;normal&quot;) ggplot(data = out_2, aes(x = .fitted, y = .std.resid)) + geom_point() + geom_hline(yintercept = 0) + theme_bw() + xlab(&quot;Fitted values&quot;) + ylab(&quot;Standardized residuals&quot;) Figure 6.9: Residual plots for the fitted model using the faculty-related factors. 6.2.4 Building the Institution-Related Factors Model To determine which of the institution-related factors to include in the model, we will examine the scatterplots of each predictor against the log-transformed peer ratings and also examine the correlation matrix of the outcome and institution-related predictors. Figure 6.10: Scatterplots of the log-transformed peer ratings versus the institution-related factors; acceptance rate of Ph.D. students, the Ph.D. student-to-faculty ratio, and the size of the program. The loess smoother is also displayed. educ %&gt;% select(Lpeer, doc_accept, phd_student_faculty_ratio, enroll) %&gt;% correlate() The three predictors are mostly uncorrelated with each other and all are correlated with the outcome, albeit enrollment is weakly correlated with peer ratings. Two of the three scatterplots suggest curvilinear relationships although with different functional forms—Ph.D. student-to-faculty ratio and total enrollment. The Rule of the Bulge indicates that log-transforming the Ph.D. student-to-faculty ratio predictor, and including quadratic may help linearize this relationship. The scatterplot of peer ratings versus total enrollment suggests that the distribution of the predictor is right-skewed with a potential outlying observations. This relationship may also benefit from log-transforming the predictor. Lastly, it is unclear whether any additional transformation or polynomial terms are necessary for modeling the relationship with doctoral acceptance rate; to double-check this we will also log-transform the total enrollment predictor. As before, prior to log-transforming any predictors, it is a good idea to check the distributions for zero or negative values. educ %&gt;% select(doc_accept, phd_student_faculty_ratio, enroll) %&gt;% summary() doc_accept phd_student_faculty_ratio enroll Min. : 4.5 Min. : 0.00 Min. : 29 1st Qu.:25.5 1st Qu.: 1.70 1st Qu.: 562 Median :38.6 Median : 2.70 Median : 842 Mean :40.1 Mean : 2.94 Mean : 970 3rd Qu.:51.6 3rd Qu.: 3.77 3rd Qu.:1312 Max. :92.7 Max. :11.70 Max. :4892 We will need to add one to every value of the phd_student_faculty_ratio predictor (so that the minimum value becomes 1) prior to the log-transformation. #Create log of the faculty-related predictors educ = educ %&gt;% mutate( Ldoc_accept = log(doc_accept), Lphd_student_faculty_ratio = log(phd_student_faculty_ratio + 1), Lenroll = log(enroll) ) Figure 6.11: Scatterplots of the log-transformed peer ratings versus the log-transformed institution-related factors. The loess smoother is also displayed. The scatterplots indicate that all three relationships were satisfactorily linearized. After fitting the institution-related factors model we will further examine the coefficient-level output and residuals. # Fit model lm.3 = lm(Lpeer ~ 1 + Ldoc_accept + Lenroll + Lphd_student_faculty_ratio, data = educ) # Coefficient-level output tidy(lm.3) # Obtain residuals out_3 = augment(lm.3) # Examine residuals sm.density(out_3$.std.resid, xlab = &quot;Standardized residuals&quot;, model = &quot;normal&quot;) ggplot(data = out_3, aes(x = .fitted, y = .std.resid)) + geom_point() + geom_hline(yintercept = 0) + theme_bw() + xlab(&quot;Fitted values&quot;) + ylab(&quot;Standardized residuals&quot;) Figure 6.12: Residual plots for the fitted model using the institution-related factors. The coefficient-level output indicates that the log-transformed enrollment predictor may be unnecessary (\\(p=0.287\\)). We will fit another model that omits this predictor, but we will also retain this initial model as it was suggested from the scientific research. # Fit model lm.4 = lm(Lpeer ~ 1 + Ldoc_accept + Lphd_student_faculty_ratio, data = educ) # Coefficient-level output tidy(lm.4) # Obtain residuals out_4 = augment(lm.4) # Examine residuals sm.density(out_4$.std.resid, xlab = &quot;Standardized residuals&quot;, model = &quot;normal&quot;) ggplot(data = out_4, aes(x = .fitted, y = .std.resid)) + geom_point() + geom_hline(yintercept = 0) + theme_bw() + xlab(&quot;Fitted values&quot;) + ylab(&quot;Standardized residuals&quot;) Figure 6.13: Residual plots for the fitted model using the institution-related factors (enrollment omitted). 6.3 Candidate Statistical Models Now that we have settled on the functional form for each of the three proposed models, we can write out the statistical models associated with the scientific hypotheses. These models using regression notation are: M1: \\(\\mathrm{Peer~Rating}_i = \\beta_0 + \\beta_1(\\mathrm{GREQ}_i) + \\beta_2(\\mathrm{GREQ}^2_i) + \\beta_3(\\mathrm{GREQ}^3_i) + \\epsilon_i\\) M2: \\(\\mathrm{Peer~Rating}_i = \\beta_0 + \\beta_1(\\mathrm{Funded~research}_i) + \\beta_2(\\mathrm{Funded~research}^2_i) + \\beta_3(\\mathrm{PhDs~granted}_i) + \\beta_4(\\mathrm{PhDs~granted}^2_i) + \\epsilon_i\\) M3: \\(\\mathrm{Peer~Rating}_i = \\beta_0 + \\beta_1(\\mathrm{PhD~acceptance~rate}_i) + \\beta_2(\\mathrm{PhD~student\\mbox{-}to\\mbox{-}faculty~ratio}_i) + \\beta_3(\\mathrm{Enrollment}_i) + \\epsilon_i\\) where peer rating, funded research, Ph.D.s granted, Ph.D. acceptance rate, enrollment, and Ph.D. student-to-faculty ratio have all been log-transformed. We will also consider a fourth model that omits enrollment from the institution-related factors model. M4: \\(\\mathrm{Peer~Rating}_i = \\beta_0 + \\beta_1(\\mathrm{PhD~acceptance~rate}_i) + \\beta_2(\\mathrm{PhD~student\\mbox{-}to\\mbox{-}faculty~ratio}_i) + \\epsilon_i\\) 6.4 Log-Likelihood Recall that the likelihood gives us the probability of a particular model given a set of data and assumptions about the model, and that the log-likelihood is just a mathematically convenient transformation of the likelihood. Log-likelihood values from different models can be compared, so long as: The exact same data is used to fit the models, The exact same outcome is used to fit the models, and The assumptions underlying the likelihood (independence, distributional assumptions) are met. In all four models we are using the same data set and outcome, and the assumptions seem reasonably tenable for each of the four fitted candidate models. This suggests that the likelihood (or log-likelihood) can provide some evidence as to which of the four candidate models is most probable. Below we compute the log-likelihood values for each of the four candidate models. logLik(lm.1) &#39;log Lik.&#39; 95.88 (df=5) logLik(lm.2) &#39;log Lik.&#39; 98.25 (df=6) logLik(lm.3) &#39;log Lik.&#39; 101.4 (df=5) logLik(lm.4) &#39;log Lik.&#39; 100.8 (df=4) Note that the log-likelihood values are also available from the glance() function’s output (in the logLik column). glance(lm.1) These values suggest that the model with the highest probability given the data and set of assumptions is Model 3; it has the highest log-likelihood value. 6.5 Deviance: An Alternative Fit Value It is common to multiply the log-likelihood values by \\(-2\\). This is called the deviance. Deviance is a measure of model-data error, so when evaluating deviance values, lower is better. (The square brackets in the syntax grab the log-likelihood value from the logLik() output.) -2 * logLik(lm.1)[1] #Model 1 [1] -191.8 -2 * logLik(lm.2)[1] #Model 2 [1] -196.5 -2 * logLik(lm.3)[1] #Model 3 [1] -202.8 -2 * logLik(lm.4)[1] #Model 4 [1] -201.7 Here, the model that produces the lowest amount of model-data error is Model 3; it has the lowest deviance value. Since the deviance just multiplies the log-likelihood values by a constant, it produces the same rank ordering of the candidate models. Thus, whether you evaluate using the likelihood, the log-likelihood, or the deviance, you will end up with the same ordering of candidate models. Using deviance, however, has the advantages of having a direct relationship to model error, so it is more interpretable. It is also more closely aligned with other model measures associated with error that we commonly use (e.g., SSE, \\(R^2\\)). 6.6 Akiake’s Information Criteria (AIC) Remember that lower values of deviance indicate the model (as defined via the set of parameters) is more likely (lower model-data error) given the data and set of assumptions. However, in practice we cannot directly compare the deviances since the models include a different number of parameters. It was not coincidence that our most probable candidate model also had the highest number of predictors. To account for this, we will add a penalty term to the deviance based on the number of parameters estimated in the model. This penalty-adjusted value is called Akiake’s Information Criteria (AIC). \\[ AIC = \\mathrm{Deviance} + 2(k) \\] where \\(k\\) is the number of parameters being estimated in the model (including the intercept and RMSE). The AIC adjusts the deviance based on the complexity of the model. Note that the value for \\(k\\) is given as df in the logLik() output. For our four models, the df values are: M1: 5 df (\\(\\hat\\beta_0\\), \\(\\hat\\beta_1\\), \\(\\hat\\beta_2\\), \\(\\hat\\beta_3\\), RMSE) M2: 6 df (\\(\\hat\\beta_0\\), \\(\\hat\\beta_1\\), \\(\\hat\\beta_2\\), \\(\\hat\\beta_3\\), \\(\\hat\\beta_4\\), RMSE) M3: 5 df (\\(\\hat\\beta_0\\), \\(\\hat\\beta_1\\), \\(\\hat\\beta_2\\), \\(\\hat\\beta_3\\), RMSE) M4: 4 df (\\(\\hat\\beta_0\\), \\(\\hat\\beta_1\\), \\(\\hat\\beta_2\\), RMSE) Just as with the deviance, smaller AIC values indicate a more likely model. -2 * logLik(lm.1)[1] + 2*5 #Model 1 [1] -181.8 -2 * logLik(lm.2)[1] + 2*6 #Model 2 [1] -184.5 -2 * logLik(lm.3)[1] + 2*5 #Model 3 [1] -192.8 -2 * logLik(lm.4)[1] + 2*4 #Model 4 [1] -193.7 Arranging these, we find that Model 4 (AIC = \\(-193.7\\)) is the most likely candidate model given the data and candidate set of models. This leads us to adopt Model 4 (the reduced model) over Model 3 (the full model) for the institution-related factors model. We can also compute the AIC via the AIC() function. # Compute AIC value for Model 4 AIC(lm.4) [1] -193.7 Lastly, we note that the AIC value is produced as a column in the model-level output. (Note that the df column from glance() does NOT give the number of model parameters.) # Model-level output for Model 4 glance(lm.4) 6.7 Empirical Support for Hypotheses Because the models are proxies for the scientific working hypotheses, the AIC ends up being a measure of empirical support for any particular hypothesis—after all, it takes into account the data (empirical evidence) and model complexity. In practice, we can use the AIC to rank order the models, which results in a rank ordering of the scientific working hypotheses based on the empirical support for each. Ranked in order of empirical support, the three scientific working hypotheses are: Peer ratings are attributable to institution-related factors. This hypothesis has the most empirical support of the three working hypotheses, given the data and other candidate models. Peer ratings are attributable to faculty-related factors. Peer ratings are attributable to student-related factors. This hypothesis has the least amount of empirical support of the three working hypotheses, given the data and other candidate models. It is important to remember that the phrase “given the data and other candidate models” is highly important. Using AIC to rank order the models results in a relative ranking of the models. It is not able to rank any hypotheses that you didn’t consider as part of the candidate set of scientific working hypotheses. Moreover, the AIC is a direct function of the likelihood which is based on the actual model fitted as a proxy for the scientific working hypothesis. If the predictors used in any of the models had been different, it would lead to different likelihood and AIC values, and potentially a different rank ordering of the hypotheses. As an example, consider if we had not done any exploration of the model’s functional form, but instead had just included the linear main-effects for each model. # Fit models lm.1 = lm(peer ~ 1 + gre_quant + gre_verbal, data = educ) lm.2 = lm(peer ~ 1 + funded_research_per_faculty + phd_granted_per_faculty, data = educ) lm.3 = lm(peer ~ 1 + doc_accept + enroll + phd_student_faculty_ratio, data = educ) # Compute AIC values AIC(lm.1) [1] 144.8 AIC(lm.2) [1] 121.6 AIC(lm.3) [1] 121 In this example, the rank-ordering of hypotheses ended up being the same, but the actual AIC values were quite different. This will play an even bigger role in the next set of notes where we compare the size of the different AIC values to look at how much more empirical support one hypothesis has versus another. Finally, it is important to mention that philosophically, the use of information-criteria for model selection is not compatible with using \\(p\\)-values for variable selection. As an example consider Model 3 and Model 4: \\[ \\begin{split} \\mathbf{Model~3:~} &amp; \\mathrm{Peer~Rating}_i = \\beta_0 + \\beta_1(\\mathrm{PhD~acceptance~rate}_i) + \\beta_2(\\mathrm{PhD~student\\mbox{-}to\\mbox{-}faculty~ratio}_i) + \\beta_3(\\mathrm{Enrollment}_i) + \\epsilon_i \\\\ \\mathbf{Model~4:~} &amp; \\mathrm{Peer~Rating}_i = \\beta_0 + \\beta_1(\\mathrm{PhD~acceptance~rate}_i) + \\beta_2(\\mathrm{PhD~student\\mbox{-}to\\mbox{-}faculty~ratio}_i) + \\epsilon_i \\end{split} \\] Using \\(p\\)-values for variable selection, we would have fitted Model 3, found that the \\(p\\)-value associated with the enrollment coefficient was non-significant, and dropped enrollment from the model. Using the AIC values however, we also dropped enrollment from the model as the AIC value for Model 4 was smaller than the AIC value for Model 3. Although in this case we came to the same conclusion, these methods are based on two very different philosophies of measuring statistical evidence. The \\(p\\)-value is a measure of how rare an observed statistic (e.g., \\(\\hat\\beta_k\\), \\(t\\)-value) is under the null hypothesis. The AIC, on the other hand, is a measure of the model-data compatibility accounting for the complexity of the model. In general, the use of \\(p\\)-values is not compatible with the use of model-level selection methods such as information criteria; see Anderson (2008) for more detail. Because of this, it is typical to not even report \\(p\\)-values when carrying out this type of analysis. References "],
["moreinfocrit.html", "Unit 7: Model Evidence 7.1 Dataset and Research Question 7.2 Corrected AIC (AICc): Adjusting for Model Complexity and Sample Size 7.3 Model-Selection Uncertainty 7.4 Relative Likelihood and Evidence Ratios 7.5 Model Probabilities 7.6 Tables of Model Evidence 7.7 Some Final Thoughts 7.8 Pretty Printing Tables of Model Evidence Other Resources", " Unit 7: Model Evidence In this set of notes, you will learn more about using information criteria to select a model from a set of candidate models. Preparation Before class you will need read the following: Burnham, K. P., Anderson, D. R., &amp; Huyvaert, K. P. (2010). AIC model selection and multimodel inference in behavioral ecology: Some background, observations, and comparisons. Behavioral Ecology and Sociobiology, 65(1), 23–35. 7.1 Dataset and Research Question In this set of notes, we will use the data in the ed-schools-2018.csv file (see the data codebook here). These data include institutional-level attributes for several graduate education schools/programs rated by U.S. News and World Report in 2018. # Load libraries library(AICcmodavg) library(broom) library(corrr) library(dplyr) library(ggplot2) library(readr) library(sm) library(tidyr) # Read in data ed = read_csv(file = &quot;~/Documents/github/epsy-8252/data/ed-schools-2018.csv&quot;) # Drop rows with missing data educ = ed %&gt;% drop_na() head(educ) # A tibble: 6 x 13 rank school score peer expert_score gre_verbal gre_quant doc_accept &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 1 Harva… 100 4.4 4.6 163 159 4.5 2 2 Stanf… 99 4.6 4.8 162 160 6.1 3 3 Unive… 96 4.2 4.3 156 152 29.1 4 3 Unive… 96 4.1 4.5 163 157 5 5 3 Unive… 96 4.3 4.5 155 153 26.1 6 6 Johns… 95 4.1 4.1 164 162 27.4 # … with 5 more variables: phd_student_faculty_ratio &lt;dbl&gt;, # phd_granted_per_faculty &lt;dbl&gt;, funded_research &lt;dbl&gt;, # funded_research_per_faculty &lt;dbl&gt;, enroll &lt;dbl&gt; In the last set of notes we used these data to examine the factors our academic peers use to rate graduate programs. Based on the substantive literature we had three scientific working hypotheses about how programs are rated: H1: Student-related factors drive the perceived academic quality of graduate programs in education. H2: Faculty-related factors drive the perceived academic quality of graduate programs in education. H3: Institution-related factors drive the perceived academic quality of graduate programs in education. After doing some initial exploration, we translates these working hypotheses into statistical models that we then fitted to the data. The four candidate models were: \\[ \\begin{split} \\mathbf{Model~1:~}&amp; \\mathrm{Peer~Rating}_i = \\beta_0 + \\beta_1(\\mathrm{GREQ}_i) + \\beta_2(\\mathrm{GREQ}^2_i) + \\beta_3(\\mathrm{GREQ}^3_i) + \\epsilon_i \\\\ \\mathbf{Model~2:~}&amp; \\mathrm{Peer~Rating}_i = \\beta_0 + \\beta_1(\\mathrm{Funded~research}_i) + \\beta_2(\\mathrm{Funded~research}^2_i) + \\beta_3(\\mathrm{PhDs~granted}_i) + \\beta_4(\\mathrm{PhDs~granted}^2_i) + \\epsilon_i \\\\ \\mathbf{Model~3:~}&amp; \\mathrm{Peer~Rating}_i = \\beta_0 + \\beta_1(\\mathrm{PhD~acceptance~rate}_i) + \\beta_2(\\mathrm{PhD~student\\mbox{-}to\\mbox{-}faculty~ratio}_i) + \\beta_3(\\mathrm{Enrollment}_i) + \\epsilon_i \\\\ \\mathbf{Model~4:~}&amp; \\mathrm{Peer~Rating}_i = \\beta_0 + \\beta_1(\\mathrm{PhD~acceptance~rate}_i) + \\beta_2(\\mathrm{PhD~student\\mbox{-}to\\mbox{-}faculty~ratio}_i) + \\epsilon_i \\end{split} \\] where peer rating, funded research, Ph.D.s granted, Ph.D. acceptance rate, enrollment, and Ph.D. student-to-faculty ratio have all been log-transformed. We will also consider a fourth model that omits enrollment from the institution-related factors model. # Create log-transformed variables educ = educ %&gt;% mutate( Lpeer = log(peer), Lfunded_research_per_faculty = log(funded_research_per_faculty), Lphd_granted_per_faculty = log(phd_granted_per_faculty + 1), Ldoc_accept = log(doc_accept), Lphd_student_faculty_ratio = log(phd_student_faculty_ratio + 1), Lenroll = log(enroll) ) # Fit candidate models lm.1 = lm(Lpeer ~ 1 + gre_quant + I(gre_quant^2) + I(gre_quant^3), data = educ) lm.2 = lm(Lpeer ~ 1 + Lfunded_research_per_faculty + I(Lfunded_research_per_faculty^2) + Lphd_granted_per_faculty + I(Lphd_granted_per_faculty^2), data = educ) lm.3 = lm(Lpeer ~ 1 + Ldoc_accept + Lenroll + Lphd_student_faculty_ratio, data = educ) lm.4 = lm(Lpeer ~ 1 + Ldoc_accept + Lphd_student_faculty_ratio, data = educ) Based on the AIC values for the four candidate models we ranked the hypotheses based on the amount of empirical support: Table 7.1: Working Hypotheses Rank Ordered by the Amount of Empirical Support as Measured by the AIC Hypothesis AIC Institution-related factors (Reduced) -193.7 Institution-related factors (Full) -192.8 Faculty-related factors -184.5 Student-related factors -181.8 7.2 Corrected AIC (AICc): Adjusting for Model Complexity and Sample Size Although AIC has a penalty correction that should account for model complexity, it turns out that when the number of parameters is large relative to the sample size, AIC is still biased in favor of models that have more parameters. This led Hurvich &amp; Tsai (1989) to propose a second-order bias corrected AIC measure (AICc) computed as \\[ \\mathrm{AIC_c} = \\mathrm{Deviance} + 2(k)\\left( \\frac{n}{n - k - 1} \\right) \\] where \\(k\\) is, again, the number of estimated parameters, and \\(n\\) is the sample size used to fit the model. Note that when \\(n\\) is very large (especially relative to \\(k\\)) that the last term is essentially 1 and the AICc value would basically reduce to the AIC value. When \\(n\\) is small relative to \\(k\\) this will add more of a penalty to the deviance. The recommendation is to pretty much always use AICc rather than AIC when selecting models. Below, we will compute the AICc for the first candidate model. (Note that we use \\(n=122\\) cases for the computation for all the models in this data.) n = 122 k = 5 # Compute AICc for Model 1 -2 * logLik(lm.1)[[1]] + 2 * k * n / (n - k - 1) #Model 1 [1] -181.2 In practice, we will use the AICc() function from the AICcmodavg package to compute the AICc value directly. AICc(lm.1) numeric(0) AICc(lm.2) numeric(0) AICc(lm.3) numeric(0) AICc(lm.4) numeric(0) Based on the \\(\\mathrm{AIC_c}\\) values, the model with the most empirical support given the data and four candidate models is Model 4. Again, because the models are proxies for the scientific hypotheses, we can rank order the scientific hypotheses based on the empirical support for each. Table 7.2: Working Hypotheses Rank Ordered by the Amount of Empirical Support Hypothesis AICc Institution-related factors (Reduced) -193.3 Institution-related factors (Full) -192.3 Faculty-related factors -183.8 Student-related factors -181.2 Moving forward, we will use the full institution-related factors model to represent the institution-related factors hypothesis. 7.3 Model-Selection Uncertainty When we adopt one model over another, we are introducing some degree of selection uncertainty into the scientific process. It would be nice if we can quantify and report this uncertainty, and this is the real advantage of using information criteria for model selection; it allows us to quantify the uncertainty we have when we select any particular candidate model. The amount of model selection uncertainty we have depends on the amount of empirical support each of the candidate models has. For example, if one particular candidate model has a lot of empirical support and the rest have very little empirical support we would have less model uncertainty than if all of the candidate models had about the same amount of empirical support. Since we measure the empirical support each hypothesis has by computing the AICc for the associated candidate model, we can look at how much more empirical support the most supported hypothesis has relative to each of the other working hypotheses by computing the difference in AICc values between the best fitting model and each of the other candidate models. This measure is referred to as # \\(\\Delta\\)AICc. In our example, the hypothesis with the most empirical support was the institution-related factors model as measured in Model 4. # Compute delta values AICc(lm.1) - AICc(lm.4) #Student-related factors numeric(0) AICc(lm.2) - AICc(lm.4) #Faculty-related factors numeric(0) AICc(lm.4) - AICc(lm.4) #Institution-related factors numeric(0) Table 7.3: Working Hypotheses Rank Ordered by the Amount of Empirical Support Hypothesis AICc \\(\\Delta\\)AICc Institution-related factors (Reduced) -193.3 0.0 Faculty-related factors -183.8 9.6 Student-related factors -181.2 12.1 Burnham, Anderson, &amp; Huyvaert (2011, p. 25) give rough guidelines for interpreting \\(\\Delta\\)AICc values. They suggest that hypotheses with \\(\\Delta\\)AICc values less than 2 are plausible, those in the range of 4–7 have some empirical support, those in the range of 9–11 have relatively little support, and those greater than 13 have essentially no empirical support. Using these criteria: The institution-related factors hypothesis (Model 4) has a lot of empirical support. The student-related factor hypothesis (Model 1) and faculty-related factor hypothesis (Model 2) both have little empirical support relative to the institution-related factors hypothesis. 7.4 Relative Likelihood and Evidence Ratios Onw way we mathematically formalize the strength of evidence for each model is to compute the relative likelihood. The relative likelihood provides the likelihood of each of the candidate models, given the set of candidate models and the data. To compute the relative likelihood, \\[ \\mathrm{Relative~Likelihood} = e ^ {−\\frac{1}{2} (\\Delta AICc)} \\] exp(-1/2 * 12.09) #Student-related factors [1] 0.00237 exp(-1/2 * 9.56) #Faculty-related factors [1] 0.008396 exp(-1/2 * 0.00) #Institution-related factors [1] 1 Table 7.4: Working Hypotheses Rank Ordered by the Amount of Empirical Support Hypothesis AICc \\(\\Delta\\)AICc Rel. Lik. Institution-related factors (Reduced) -193.3 0.0 1.000 Faculty-related factors -183.8 9.6 0.008 Student-related factors -181.2 12.1 0.002 Note. Rel. Lik. = Relative Likelihood These quantities allow evidentiary statements for comparing any two scientific hypotheses. For example, The empirical support for the faculty-related factors hypothesis is 0.008 times that of the empirical support for the institution-related factors hypothesis. To obtain these evidence ratios, we divide the relative likelihood for any two hypotheses. This will quantify how much more likely one hypothesis is than another given the data. As another example, The empirical support for the institution-related factors hypothesis is 500 times that of the empirical support for the student-related factors hypothesis. (To obtain this we computed \\(1/.002=500\\).) 7.5 Model Probabilities Also referred to as an Akaike Weight (\\(w_i\\)), a model probability provides a numerical measure of the probability of each model given the data and the candidate set of models. It can be computed as: \\[ w_i = \\frac{\\mathrm{Relative~Likelihood~for~Model~J}}{\\sum_j \\mathrm{Relative~Likelihood}} \\] # Compute sum of relative likelihoods sum_rel = 1.000000000 + 0.008376636 + 0.002366380 0.002366380 / sum_rel #Student-related factors [1] 0.002341 0.008376636 / sum_rel #Faculty-related factors [1] 0.008288 1.000000000 / sum_rel #Institution-related factors [1] 0.9894 Since the models are proxies for the working hypotheses, the model probabilities can be used to provide probabilities of each working hypothesis as a function of the empirical support. Given the data and the candidate set of working hypotheses: The probability of the student-related factors hypothesis is 0.002 (very unlikely). The probability of the faculty-related factors hypothesis is 0.008 (very unlikely). The probability of the institution-related factors hypothesis is 0.990 (very likely). Table 7.5: Working Hypotheses Rank Ordered by the Amount of Empirical Support Hypothesis AICc \\(\\Delta\\)AICc Rel. Lik. AICc Weight Institution-related factors (Reduced) -193.3 0.0 1.000 0.989 Faculty-related factors -183.8 9.6 0.008 0.008 Student-related factors -181.2 12.1 0.002 0.002 Note. Rel. Lik. = Relative Likelihood 7.6 Tables of Model Evidence We will use the aictab() function from the AICcmodavg package to compute and create a table of model evidence values directly from the lm() fitted models. This function takes a list of models in the candidate set (it actually has to be an R list). The optional argument modnames= is a vector of model names associated with the models in the candidate set. myAIC = aictab( cand.set = list(lm.1, lm.2, lm.4), modnames = c(&quot;Student-related factors&quot;, &quot;Faculty-related factors&quot;, &quot;Institution-related factors (Reduced)&quot;) ) # View table myAIC Model selection based on AICc: K AICc Delta_AICc AICcWt Cum.Wt LL Institution-related factors (Reduced) 4 -193.33 0.00 0.99 0.99 100.84 Faculty-related factors 6 -183.76 9.56 0.01 1.00 98.25 Student-related factors 5 -181.24 12.09 0.00 1.00 95.88 Note the output includes the number of parameters (K) and AICc value (AICc) for each candidate model, and prints them in order from the most empirical evidence to the least amount of empirical evidence based on the AICc. It also includes the \\(\\Delta\\)AICc values, the model probabilities (AICcWt), and log-likelihood (LL) values. The Cum.Wt column gives the cumulative model probabilities. (For example the probability of the first two hypotheses is \\(0.99 + 0.01 = 1.00\\).) You can also directly compute the evidence ratios, but you have to do that separately. We do this using the evidence() function from the AICcmodavg package. This function takes the output from the aictab() function as well as the names from that table (given in the modnames= argument) for the two models you want to compute the evidence ratio for. # Evidence Ratio 1 evidence( myAIC, model.high = &quot;Institution-related factors (Reduced)&quot;, model.low = &quot;Faculty-related factors&quot; ) Evidence ratio between models &#39;Institution-related factors (Reduced)&#39; and &#39;Faculty-related factors&#39;: 119.4 # Evidence Ratio 2 evidence( myAIC, model.high = &quot;Institution-related factors (Reduced)&quot;, model.low = &quot;Student-related factors&quot; ) Evidence ratio between models &#39;Institution-related factors (Reduced)&#39; and &#39;Student-related factors&#39;: 422.6 7.7 Some Final Thoughts Based on the model evidence given the data for this candidate set of models: The institution-related factors hypothesis has the most empirical support. There is very little empirical support for the other two hypotheses relative to the institution-related factors hypothesis. We can get a summary of the model rankings along with qualitative descriptors of the empirical support (weight) using the confset() function. The method=\"ordinal\" argument rank orders the models for us. confset( cand.set = list(lm.1, lm.2, lm.4), modnames = c(&quot;Student-related factors&quot;, &quot;Faculty-related factors&quot;, &quot;Institution-related factors (Reduced)&quot;), method = &quot;ordinal&quot; ) Confidence set for the best model Method: ordinal ranking based on delta AIC Models with substantial weight: K AICc Delta_AICc AICcWt Institution-related factors (Reduced) 4 -193.3 0 0.99 Models with some weight: K AICc Delta_AICc AICcWt Models with little weight: K AICc Delta_AICc AICcWt Faculty-related factors 6 -183.8 9.56 0.01 Models with no weight: K AICc Delta_AICc AICcWt Student-related factors 5 -181.2 12.09 0 It is important to note that it is ultimately the set of scientific working hypotheses that we are evaluating, using the fit from the associated statistical models to a set of empirical data. If we had a different set of data, we may have a whole new ranking of models or interpretation of empirical support. The empirical support is linked to the data. The amount of empirical evidence is also very much relative to the candidate set of models; a different candidate set of models may result in a different rank ordering or interpretation of empirical support. For example, consider if we had not done any exploration of the model’s functional form, but instead had just included the linear main-effects for each model. # Fit models lm.1 = lm(peer ~ 1 + gre_quant + gre_verbal, data = educ) lm.2 = lm(peer ~ 1 + funded_research_per_faculty + phd_granted_per_faculty, data = educ) lm.3 = lm(peer ~ 1 + doc_accept + enroll + phd_student_faculty_ratio, data = educ) confset( cand.set = list(lm.1, lm.2, lm.3), modnames = c(&quot;Student-related factors&quot;, &quot;Faculty-related factors&quot;, &quot;Institution-related factors (Full)&quot;), method = &quot;ordinal&quot; ) Confidence set for the best model Method: ordinal ranking based on delta AIC Models with substantial weight: K AICc Delta_AICc AICcWt Institution-related factors (Full) 5 121.5 0.0 0.55 Faculty-related factors 4 121.9 0.4 0.45 Models with some weight: K AICc Delta_AICc AICcWt Models with little weight: K AICc Delta_AICc AICcWt Models with no weight: K AICc Delta_AICc AICcWt Student-related factors 4 145.1 23.62 0 Based on the model evidence given the data for this candidate set of models: The institution-related factors hypothesis still has the most empirical support. But, the faculty-related factors hypothesis now also has substantial empirical support as well (\\(\\Delta\\mathrm{AICc}=0.4\\)). There is almost no empirical support for the student-related factors hypothesis relative to the other two hypotheses. 7.8 Pretty Printing Tables of Model Evidence We can use the data.frame() function to coerce the output from the aictab() function into a data frame. Then we can use dplyr functions to select the columns in the order we want them, add the column of evidence ratios, and re-name any column we want. Lastly, we can use the kable() function from the knitr package and other functions from the kableExtra package to format the table for pretty-printing in Markdown. # Create data frame to format into table tab_07 = data.frame(myAIC) %&gt;% select( Modnames, LL, K, AICc, Delta_AICc, AICcWt ) %&gt;% mutate( ER = max(AICcWt) / AICcWt ) %&gt;% rename( Hypothesis = Modnames, # We can include LaTeX math notation in column names # Because \\ is a special character we need two \\\\ &#39;$\\\\Delta$AICc&#39; = Delta_AICc, &#39;AIC Wt.&#39; = AICcWt ) # Load libraries for formatting library(knitr) library(kableExtra) # Format the table output kable(tab_07, caption = &quot;Table of Model Evidence for Three Working Hypotheses&quot;, digits = 2 ) %&gt;% footnote( general = &quot;LL = Log-Likelihood; K = Model df; AIC Wt. = Model Probability; ER = Evidence Ratio&quot;, general_title = &quot;Note.&quot;, footnote_as_chunk = TRUE ) Table 7.6: Table of Model Evidence for Three Working Hypotheses Hypothesis LL K AICc \\(\\Delta\\)AICc AIC Wt. ER Institution-related factors (Reduced) 100.84 4 -193.3 0.00 0.99 1.0 Faculty-related factors 98.25 6 -183.8 9.56 0.01 119.4 Student-related factors 95.88 5 -181.2 12.09 0.00 422.6 Note. LL = Log-Likelihood; K = Model df; AIC Wt. = Model Probability; ER = Evidence Ratio Other Resources In addition to the notes and what we cover in class, there many other resources for learning information criteria for model selection. Here are some resources that may be helpful in that endeavor: Anderson, David R. (2008). Model based inference in the life sciences: A primer on evidence. New York: Springer. Burnham, Kenneth P., &amp; Anderson, David R. (2002). Model selection and multimodel inference: A practical information-theoretic approach. New York: Springer. For table formatting using R Markdown, check out: kableExtra Documentation gt Documentation References "],
["intro-lmer.html", "Unit 8: Introduction to Mixed-Effects Models 8.1 Dataset and Research Question 8.2 Join the Student- and Classroom-Level Data 8.3 Fixed-Effects Regression Model 8.4 Conceptual Idea of Mixed-Effects Models 8.5 Fitting the Mixed-Effects Regression Model in Practice 8.6 Example 2: Life Satisfaction of NBA Players", " Unit 8: Introduction to Mixed-Effects Models In this set of notes, you will learn the conceptual ideas behind linear mixed-effects models, also called multilevel models or hierarchical linear models. Preparation Before class you will need to read the Relational data chapter from following: Grolemund, G., &amp; Wickham, H. (2017). R for Data Science: Visualize, model, transform, tidy, and import data. **. Sebastopol, CA: O’Reilly. Focus on the information on mutating joins. 8.1 Dataset and Research Question In this set of notes, we will use data from two files, the netherlands-students.csv file and the netherlands-schools.csv files (see the data codebook here). These data include student- and school-level attributes, respectively, for \\(n_i=2287\\) 8th-grade students in the Netherlands. # Load libraries library(broom) library(dplyr) library(ggplot2) library(lme4) #for fitting mixed-effects models library(readr) library(sm) # Read in student-level data student_data = read_csv(file = &quot;~/Documents/github/epsy-8252/data/netherlands-students.csv&quot;) head(student_data) # A tibble: 6 x 8 student_id school_id language_pre language_post ses verbal_iq female &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 17001 1 36 46 23 3.17 0 2 17002 1 36 45 10 2.67 0 3 17003 1 33 33 15 -2.33 0 4 17004 1 29 46 23 -0.834 0 5 17005 1 19 20 10 -3.83 0 6 17006 1 22 30 10 -2.33 0 # … with 1 more variable: minority &lt;dbl&gt; # Read in school-level data school_data = read_csv(file = &quot;~/Documents/github/epsy-8252/data/netherlands-schools.csv&quot;) head(school_data) # A tibble: 6 x 5 school_id school_type school_ses school_verbal_iq school_minority &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 1 Public 11 -1.51 60 2 2 Public 11 -2.83 10 3 10 Public 15 -1.33 4 4 12 Public 20 -2.40 5 5 15 Catholic 18 -0.334 25 6 16 Protestant 13 -0.147 0 We will use these data to explore the question of whether verbal IQ scores predict variation in post-test language scores. 8.2 Join the Student- and Classroom-Level Data Before analyzing the data, we need to join, or merge, the two datasets together. To do this, we will use the left_join() function from the dplyr package. dplyr includes six different join functions. You can read about several different join functions here. joined_data = left_join(student_data, school_data, by = &quot;school_id&quot;) head(joined_data) 8.3 Fixed-Effects Regression Model To examine the research question of whether verbal IQ scores predict variation in post-test language scores, we might regress language scores on the verbal IQ scores using the lm() function. The lm() function fits a fixed-effects regression model. lm.1 = lm(language_post ~ 1 + verbal_iq, data = joined_data) # Model-level output glance(lm.1) # Coefficient-level output tidy(lm.1) The model-level summary information suggests that differences in verbal IQ scores explains 37.2% of the variation in post-test language scores, \\(F(1,2285)=1352.84\\), \\(p&lt;0.001\\). The estimated intercept suggests that the average predicted post-test language scores for students with a mean verbal IQ score (= 0) is 40.93 (\\(p&lt;.001\\)). The estimated slope indicates that each one-point difference in verbal IQ score is associated with a difference in post-test language scores of \\(2.65\\), on average (\\(p&lt;.001\\)). To have faith in the analytic results from this model, we need to evaluate whether the assumptions are satisfied. 8.3.1 Residual Analysis # Obtain the fortified data frame out = augment(lm.1) head(out) # Normality sm.density(out$.std.resid, model = &quot;normal&quot;, xlab = &quot;Standardized residuals&quot;) # All other assumptions ggplot(data = out, aes(x = .fitted, y = .std.resid)) + geom_point() + geom_hline(yintercept = 0) + theme_bw() + xlab(&quot;Fitted values&quot;) + ylab(&quot;Standardized residuals&quot;) Figure 8.1: Density plot of the standardized residuals and scatterplot of the standardized residuals versus the fitted values from the fixed-effects regression model. The assumption that the mean residual is 0 seems reasonably satisfied, however those of normality and homoscedasticity seem less feasible, especially given the large sample size. More importantly, the assumption of independence (which we don’t evaluate from the common residual plots) is probably not tenable. Students’ post-test language scores (and thus the residuals) are probably correlated within schools—this is a violation of independence which assumes that the correlation between student’s residuals is 0. If we have a variable that identifies classroom, we can actually examine this by plotting the residuals separately for each classroom. In our case, we do have a variable that identifies classroom (school_id). We need to mutate this variable into the augmented dataset. This variable has 131 different levels, which means that we would be looking at 131 different residual plots. When we use facet_wrap() with that many levels each plot will be too small to see, so we will instead select a random sample of, say, 25 of the classrooms to evaluate. # Make random sample reproducible set.seed(100) # Draw random sample of 25 schools without replacement my_sample = sample(school_data$school_id, size = 25, replace = FALSE) # Mutate on school ID and draw random sample out = out %&gt;% mutate(school_id = joined_data$school_id) %&gt;% filter(school_id %in% my_sample) ### Show residuals by school ggplot(data = out, aes(x = .fitted, y = .std.resid)) + geom_point() + geom_hline(yintercept = 0) + theme_bw() + xlab(&quot;Fitted values&quot;) + ylab(&quot;Studentized residuals&quot;) + facet_wrap(~school_id, nrow = 5) Figure 8.2: Scatterplots of the standardized residuals versus the fitted values from the fixed-effects regression model stratified by team. The residuals for several of the schools show a systematic trends of being primarily positive or negative within schools. For example, the residuals for several schools (e.g., 47, 256 258) are primarily negative. This is a sign of non-independence of the residuals. If we hadn’t had the school ID variable we could have still made a logical argument about this non-independence via substantive knowledge. For example, students who attend a “high performing” will likely tend to have positive residuals (scores above average relative to the population), even after accounting for their verbal IQ scores. To account for this within-school correlation we need to use a statistical model that accounts for the correlation among the residuals within schools. This is what mixed-effects models bring to the table. By correctly modeling the non-independence, we get more accurate standard errors and p-values. Another benefit of using mixed-effects models is that we also get estimates of the variation accounted for at both the school- and student-levels. This disaggregating of the variation allows us to see which level is explaining more variation and to study predictors appropriate to explaining that variation. For example, suppose that you disaggregated the variation in language scores and found that: 96% of the variation in these scores was at the student-level, and 3% of the variation in these scores was at the classroom-level, and 1% of the variation in these scores was at the school-level. By including school-level or classroom-level predictors in the model, you would only be “chipping away” at that 1% or 3%, respectively. You should focus your attention and resources on student-level predictors! 8.4 Conceptual Idea of Mixed-Effects Models In this section we will outline the conceptual ideas behind mixed-effects models by linking the ideas behind these models to the conventional, fixed-effects regression model. It is important to realize that this is just conceptual in nature. Its purpose is only to help you understand the output you get from a mixed-effects model analysis. To begin, we remind you of the fitted equation we obtained earlier from the fixed-effects regression: \\[ \\hat{\\mathrm{Language~Score}_i} = 34.19 + 2.04(\\mathrm{Verbal~IQ}_i) \\] Mixed-effects regression actually fits a global model (like the one above) AND a school-specific model for each school. Conceptually, this is like fitting a regression model for each school separately. Below I show the results (for 5 of the schools) of fitting a different regression model to each school, but keep in mind that this is only to help you understand. # Fit school models school_models = joined_data %&gt;% group_by(school_id) %&gt;% do(mod = lm(language_post ~ 1 + verbal_iq, data = .)) %&gt;% tidy(mod) %&gt;% head(., 10) # View coefficients from fitted models school_models As an example, let’s focus on the fitted model for School 1. \\[ \\hat{\\mathrm{Language~Score}_i} = 39.79 + 2.24(\\mathrm{Verbal~IQ}_i) \\] Comparing this school-specific model to the global model, we find that School 1’s intercept is higher than the intercept from the global model (by 5.65) and it’s slope is also higher than the slope from the global model (by 0.20). We can actually re-write the school-specific model using these ideas: \\[ \\hat{\\mathrm{Language~Score}_i} = \\bigg[34.19 + 5.65\\bigg] + \\bigg[2.04 + 0.20\\bigg](\\mathrm{Verbal~IQ}_i) \\] In the language of mixed-effects modeling: The global intercept and slope are referred to as fixed-effects. (These are also sometimes referred to as between-groups effects.) The fixed-effect of intercept is \\(34.19\\); and The fixed effect of the slope is \\(2.04\\). The school-specific deviations from the fixed-effect values are referred to as random-effects. (These are also sometimes referred to as within-groups effects.) The random-effect of the intercept for School 1 is \\(+5.65\\); and The random-effect of the slope for School 1 is \\(+0.20\\). Note, each school could potentially have a different random-effect for intercept and slope. For example, writing the team-specific fitted equation for School 2 in this manner, \\[ \\begin{split} \\hat{\\mathrm{Language~Score}_i} &amp;= 27.35 + 1.28(\\mathrm{Verbal~IQ}_i)\\\\ &amp;= \\bigg[34.19 - 6.84\\bigg] + \\bigg[2.04 - 0.76\\bigg](\\mathrm{Verbal~IQ}_i).\\\\ \\end{split} \\] In this model: The fixed-effects (global effects) are the same as they were for School 1. The fixed-effect of intercept is \\(34.19\\); and The fixed effect of the slope is \\(2.04\\). The random-effect of intercept for School 2 is \\(-6.84\\). The random-effect of slope for School 2 is \\(-0.76\\). 8.5 Fitting the Mixed-Effects Regression Model in Practice In practice, we use the lmer() function from the lme4 library to fit mixed-effect regression models. This function will essentially do what we did in the previous section, but rather than independently fitting the team-specific models, it will fit all these models simultaneously and make use of the information in all the clusters (schools) to do this. This will result in better estimates for both the fixed- and random-effects. The syntax looks similar to the syntax we use in lm() except now we split it into two parts. The first part of the syntax gives a model formula to specify the outcome and fixed-effects included in the model. This is identical to the syntax we used in the lm() function. In our example: language_post ~ 1 + verbal_iq indicating that we want to fit a model that includes fixed-effects for both the intercept and the effect of verbal IQ score. We also have to declare that we want to fit a model for each school. To do this, we will include a random-effect for intercept. (We could also include a random-effect of verbal IQ, but to keep it simpler right now, we only include the RE of intercept.) The second part of the syntax declares this: (1 | school_id). This says fit school-specific models that vary in their intercepts. This is literally added to the fixed-effects formula using +. The complete syntax is: # Fit mixed-effects regression model lmer.1 = lmer(language_post ~ 1 + verbal_iq + (1 | school_id), data = joined_data) To view the fixed-effects, we use the fixef() function. fixef(lmer.1) (Intercept) verbal_iq 40.608 2.488 This gives the coefficients for the fixed-effects part of the model (i.e., the global model), \\[ \\hat{\\mathrm{Language~Score}_{ij}} = 40.61 + 2.49(\\mathrm{Verbal~IQ}_{ij}) \\] Note that the notation now includes two subscripts. The i subscript still indicates the ith student, and the new j subscript indicates that the student was from the jth school. Since we accounted for school in the model (schools are allowed to have different intercepts) we need to now identify that in the equation. We interpret these coefficients from the fixed-effects equation exactly like lm() coefficients. Here, The predicted average post-test language score for students with a mean verbal IQ score (=0) is 40.61. Each one-point difference in verbal IQ score is associated with a 2.49-point difference in language scores, on average. To view the school-specific random-effects, we use the ranef() function (only the first 5 rows are shown). ranef(lmer.1) $school_id (Intercept) 1 -0.37573940 2 -6.04469893 10 -3.66481710 12 -2.91463441 15 -5.74351132 The random-effects indicate how the school-specific intercept differs from the overall average intercept. For example, the intercept for School 1 is approximately 0.38-points lower than the average intercept of 40.61 (the fixed-effect). This implies that, on average, students from School 1 with a mean verbal IQ score (=0) have an average post-test language score that is 0.38-points lower than their peers who also have a mean verbal IQ score. From the estimated fixed- and random-effects, we can re-construct each school-specific fitted equation if we are so inclined. For example, to construct the school-specific fitted equation for School 1, we combine the estimated coefficients for the fixed-effects and the estimated random-effect for School 1: \\[ \\begin{split} \\hat{\\mathrm{Language~Score}_{i}} &amp;= \\bigg[ 40.61 -0.376 \\bigg]+ 2.49(\\mathrm{Verbal~IQ}_{i}) \\\\[1ex] &amp;= 40.2 + 2.49(\\mathrm{Verbal~IQ}_{i}) \\end{split} \\] In this notation, the j part of the subscript is dropped since j is now fixed to a specific school; \\(j=1\\). 8.6 Example 2: Life Satisfaction of NBA Players As a second example, we will explore the question of whether NBA players’ success is related to life satisfaction. To do this, we will use two datasets, the nba-player-data.csv and nba-team-data.csv file (see the data codebook here). These data include player- and team-level attributes for \\(n=300\\) players and \\(n=30\\) teams, respectively. To begin, we will import both the player-level and team-level datasets and then join them together. # Read in player-level data nba_players = read_csv(file = &quot;~/Documents/github/epsy-8252/data/nba-player-data.csv&quot;) # Read in team-level data nba_teams = read_csv(file = &quot;~/Documents/github/epsy-8252/data/nba-team-data.csv&quot;) # Join the datasets together nba = nba_players %&gt;% left_join(nba_teams, by = &quot;team&quot;) head(nba) We want to fit a model that regresses the life_satisfaction scores on the success values. In these data, however, we might expect that the life satisfaction of players is correlated within team. To account for that fact, we can include a random-effect of intercept in our regression model. 8.6.1 Fit the Mixed-Effects Model Below we fit a mixed-effects regression model to predict variation in life satisfaction scores that includes success as a predictor. We also include a random-effect of intercept to account for the within-team correlation of life satisfaction scores. The statistical model is: \\[ \\mathrm{Life~Satisfaction}_{ij} = \\bigg[\\beta_0 + b_{0j} \\bigg] + \\beta_1(\\mathrm{Success}_{ij}) + \\epsilon_{ij} \\] We fit the model using lmer() as: # Fit model lmer.1 = lmer(life_satisfaction ~ 1 + success + (1 | team), data = nba) We can then extract the fixed-effects estimates using the fixef() function. # Get fixed-effects fixef(lmer.1) (Intercept) success 11.575 1.666 We write the fitted fixed-effects model as: \\[ \\hat{\\mathrm{Life~Satisfaction}}_{ij} = 11.57 + 1.67(\\mathrm{Success}_{ij}) \\] Again, we can interpret these fixed-effects estimates the same way we do any other regression coefficient. The predicted average life satisfaction for NBA players with a success score of 0 (free-throw percentage in the lowest 20%) is 11.57. Each one-unit difference in success (one-quantile difference) is associated with a 1.67-point difference in life satisfaction score, on average. If we are interested in the fitted model for a SPECIFIC team, we can extract the random-effect of intercept for that team and add it to the fixed-effect intercept estimate. For example, the equation for the Minnesota Timberwolves is: # Obtain random-effects ranef(lmer.1) $team (Intercept) Atlanta Hawks 2.7474 Boston Celtics 5.3594 Brooklyn Nets 4.1005 Charlotte Hornets 1.1515 Chicago Bulls -3.4811 Cleveland Cavaliers 0.9739 Dallas Mavericks -6.1708 Denver Nuggets 4.0877 Detroit Pistons -2.3659 Golden State Warriors -1.8955 Houston Rockets -2.3038 Indiana Pacers -1.4244 Los Angeles Clippers 5.5528 Los Angeles Lakers -5.0071 Memphis Grizzlies 0.6391 Miami Heat 0.6749 Milwaukee Bucks -5.8198 Minnesota Timberwolves 3.6616 New Orleans Pelicans -1.3426 New York Knicks -1.9479 Oklahoma City Thunder -1.5291 Orlando Magic -3.4961 Philadelphia 76ers 4.6167 Phoenix Suns -6.1341 Portland Trail Blazers 0.3600 Sacramento Kings -3.4140 San Antonio Spurs 0.1794 Toronto Raptors 3.8491 Utah Jazz 6.2954 Washington Wizards 2.0828 \\[ \\begin{split} \\hat{\\mathrm{Life~Satisfaction}}_{i} &amp;= \\bigg[11.57 + 3.66 \\bigg] + 1.67(\\mathrm{Success}_{i}) \\\\[1ex] &amp;= 15.23 + 1.67(\\mathrm{Success}_{i}) \\end{split} \\] For Timberwolves players, The predicted average life satisfaction for Timberwolves players with a success score of 0 (free-throw percentage in the lowest 20%) is 15.23. This is a score that is 3.66 points above average for all NBA players with a success score of 0. Each one-unit difference in success is associated with a 1.67-point difference in life satisfaction score for Timberwolves players, on average. This is the same rate-of-change as for NBA players in general. As a comparison, we can also consider the equation for the Phoenix Suns: \\[ \\begin{split} \\hat{\\mathrm{Life~Satisfaction}}_{i} &amp;= \\bigg[11.57 - 6.13 \\bigg] + 1.67(\\mathrm{Success}_{i}) \\\\[1ex] &amp;= 5.44 + 1.67(\\mathrm{Success}_{i}) \\end{split} \\] The predicted average life satisfaction for Suns players with a success score of 0 (free-throw percentage in the lowest 20%) is 5.44. This is a score that is 6.13 points below average for all NBA players with a success score of 0. Each one-unit difference in success is associated with a 1.67-point difference in life satisfaction score for Suns players, on average. This is the same rate-of-change as for NBA players in general. Comparing these two team’s equations gives us some insight into why the effects are referred to as fixed-effects or random-effects. \\[ \\begin{split} \\mathbf{Timberwolves:~}\\hat{\\mathrm{Life~Satisfaction}}_{i} &amp;= \\bigg[11.57 + 3.66 \\bigg] + 1.67(\\mathrm{Success}_{i}) \\\\[1ex] \\mathbf{Suns:~}\\hat{\\mathrm{Life~Satisfaction}}_{i} &amp;= \\bigg[11.57 - 6.13 \\bigg] + 1.67(\\mathrm{Success}_{i}) \\\\[1ex] \\end{split} \\] In the two equations, the fixed-effects of intercept (11.57) and success (1.67) are represented in both equations; they are fixed. On the other hand, the random-effect is different for each team. Since we included a random-effect of intercept in out model, this means that the intercept value for each team equation will be different. "],
["data-codebook.html", "Data Codebooks ed-schools-2018.csv evaluations.csv fci-2015.csv mn-schools.csv movies.csv nba-player-data.csv and nba-team-data.csv netherlands-students.csv and netherlands-schools.csv popular-classroom.csv and popular-student.csv riverview.csv wine.csv", " Data Codebooks The data codebooks provide information about the attributes and source of each of the datasets used in the notes. ed-schools-2018.csv The data in ed-schools-2018.csv come from U.S. News and World Report (2018) and contain 13 attributes collected from the \\(n=129\\) graduate schools of education ranked in the 2018 Best Graduate Schools. The attributes include: rank: Rank in USNWR school: Graduate program of Education score: Overall score given by USNWR peer: Peer assessment score (5.0 = highest) expert_score: Administrator/expert assessment score (5.0 = highest) gre_verbal: Mean GRE verbal score in 2016 gre_quant: Mean GRE quantitative score in 2016 doc_accept: Acceptance rate for doctoral students in 2016 student_faculty_ratio: Ratio of doctoral students to faculty members in 2016 phd_granted_per_faculty: Doctorates granted per faculty member in 2015–16 funded_research: Funded research (in millions of dollars) funded_research_per_faculty: Funded research per faculty member (in thousands of dollars) enroll: Total graduate education enrollment in 2016 evaluations.csv This file contains data collected from student evaluations of instructors’ beauty and teaching quality for several courses at the University of Texas. The teaching evaluations were conducted at the end of the semester, and the beauty judgments were made later, by six students who had not attended the classes and were not aware of the course evaluations. The variables are: prof_id: Professor ID number avg_eval: Average course rating num_courses: Number of courses for which the professor has evaluations num_students: Number of students enrolled in the professor’s courses perc_evaluating: Average percentage of enrolled students who completed an evaluation beauty: Measure of the professor’s beauty composed of the average score on six standardized beauty ratings tenured: Is the professor tenured? (0 = non-tenured; 1 = tenured) native_english: Is the professor a native English speaker? (0 = non-native English speaker; 1 = native English speaker) age: Professor’s age (in years) female: Is the professor female? (0 = male; 1 = female) These source of these data is: Hamermesh, D. S. &amp; Parker, A. M. (2005). Beauty in the classroom: Instructors’ pulchritude and putative pedagogical productivity. Economics of Education Review, 24, 369–376. The data were made available by: Gelman, A., &amp; Hill, J. (2007). Data analysis using regression and multilevel/hierarchical models. New York: Cambridge University Press. fci-2015.csv Each season, Team Marketing Report (TMR) computes the cost of taking a family of four to a professional sports contest for each of the major sporting leagues. Costs are determined by telephone calls with representatives of the teams, venues and concessionaires. Identical questions were asked in all interviews. Prices for Canadian teams were converted to US dollars and comparison prices were converted using a recent exchange rate. Salary data were collected by Sporting Intelligence as part of their Global Sports Salaries Survey 2015. The data in fci-2015.csv include five attributes collected from from the 2014/2015 season for \\(n=122\\) professional sports teams across the United States. The attributes include: team: Name of professional sports team league: Major sporting league the team plays in (MLB = Major Lague Baseball; NBA = National Basketball Association; NFL = National Football League; NHL = National Hockey League) fci: Fan Cost Index (FCI). The FCI is a summary of what it costs to take a family of four to a game. It comprises the prices of four (4) adult average-price tickets, two (2) small draft beers, four (4) small soft drinks, four (4) regular-size hot dogs, parking for one (1) car, two (2) game programs and two (2) least expensive, adult-size adjustable caps. salary: Average yearly salary for players on the active roster mn-schools.csv The data in mnSchools.csv were collected from http://www.collegeresults.org and contain 2011 institutional data for \\(n=33\\) Minnesota colleges and universities. The attributes include: name: College/university name grad: Six-year graduation rate, as a percentage public: Sector (1 = public college/university, 0 = private college/university) sat: Estimated median composite SAT score (in hundreds) tuition: Amount of tuition and required fees covering a full academic year for a typical student, in thousands of U.S. dollars movies.csv The data in movies.csv includes attributes for \\(n=1,806\\) movies. These data are a subset of data from the movies data object included in the ggplot2movies package. The original data contains information on 24 variables collected from 28,819 movies. The attributes include: title: Movie’s title budget: Movie’s budget (in millions of U.S. dollars) age: Age of the movie; Computed by subtracting the movie’s release date from 2019 mpaa: MPAA rating (PG, PG-13, R) nba-player-data.csv and nba-team-data.csv The data in nba-player-data.csv and nba-team-data.csv, inspired by Woltman, Feldstein, MacKay, &amp; Rocchi (2012), include player-level attributes for \\(n=300\\) NBA players, and team-level attributes for \\(N=30\\) different teams, respectively. The player-level attributes in nba-player-data.csv include: player: Name of the NBA player team: Name of the NBA team for each player success: A proxy for player quality/success. This is the quantile for the player based on the player’s free-throw percentage relative to the other players in the league. Higher values indicate a more succesful player (e.g., 0 = lowest 20%; 4 = highest 20%). life_satisfaction: Score on a survey of life satisfaction. Scores range from 5 to 25, with higher scores indicating more life satisfaction. The team-level attributes in nba-team-data.csv include: team:Name of the NBA team coach:Name of the team’s current coach coach_experience: This is the tercile for the coach based on years of coaching experience in the NBA (e.g., 0 = lowest third; 2 = highest third). netherlands-students.csv and netherlands-schools.csv The data in netherlands-students.csv and netherlands-schools.csv include student- and school-level attributes, respectively, for \\(n_i=2287\\) 8th-grade students in the Netherlands provided by Snijders &amp; Bosker (2012). The student-level attributes in netherlands-students.csv include: school_id: The school ID number for each student language_pre: Language pre-test score language_post: Language post-test score ses: Measure of the socio-economic status verbal_iq: Student’s score on a verbal IQ test. The variable is centered to have a mean of 0. female: Student’s sex (0 = male; 1 = female) minority: Student’s minority status (0 = white; 1 = minority) The school-level attributes in netherlands-schools.csv include: school_id: The school ID number school_type: Indicates whether the school is a public school, a Protestant private school, a Catholic private school, or a non-denominational private school school_ses: School’s average socio-economic status school_verbal_iq: School’s average verbal IQ score school_minority: Percentage of students at the school who are minority students popular-classroom.csv and popular-student.csv The data in popular-classroom.csv and popular-student.csv includes data on 2000 different students from 100 different classrooms. The data, provided by Hox (2002), were simulated from data collected as part of a sociological study of student popularity. Student popularity, a rating on a scale of 1–10, was derived by a sociometric procedure in which all students in a class rate all the other students. Each students’ popularity is the average received popularity rating. The attributes in popular-classroom.csv include: class: Classroom ID teacherExp: Experience level of teacher, in years The attributes in popular-student.csv include: student: Student ID (within a school) class: Classroom ID popularity: Popularity rating of the student (0-10 scale; where 0 = very unpopular and 10 = very popular) based on having all other students in the student’s class rate him/her and computing the average of those ratings. teachPop: Student’s popularity as rated by the teacher. Higher values are indicative of higher popularity extra: Extraversion of the student (measured on a 10-point scale) female: Sex of the student (Male = 0; Female = 1) riverview.csv The data in riverview.csv come from Lewis-Beck &amp; Lewis-Beck (2016) and contain five attributes collected from a random sample of \\(n=32\\) employees working for the city of Riverview, a hyopothetical midwestern city. The attributes include: education: Years of formal education income: Annual income (in thousands of U.S. dollars) seniority: Years of seniority gender: Employee’s gender male: Dummy coded gender variable (0 = Female, 1 = Male) party: Political party affiliation wine.csv The data in wine.csv includes data on 200 different wines. These data are a subset of a larger database (\\(n = 6,613\\)) from wine.com, one of the biggest e-commerce wine retailers in the U.S. It allows customers to buy wine according to any price range, grape variety, country of origin, etc. The data were made available at http://insightmine.com/. The attributes include: wine: Wine name vintage: Year the wine was produced (centered so that 0 = 2008, 1 = 2009, etc.) region: Region of the world where the wine was produced varietal: Grape varietal (e.g., Cabernet Sauvignon) rating: Wine rating on a 100 pt. scale (these are from sources such as Wine Spectator, the Wine Advocate, and the Wine Enthusiast) price: Price in U.S. dollars References "],
["references.html", "References", " References "]
]
